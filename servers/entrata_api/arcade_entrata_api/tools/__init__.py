"""Arcade Starter Tools for Entrata

DO NOT EDIT THIS MODULE DIRECTLY.

THIS MODULE WAS AUTO-GENERATED BY TRANSPILING THE API STARTER TOOL JSON DEFINITIONS
IN THE ../wrapper_tools DIRECTORY INTO PYTHON CODE. ANY CHANGES TO THIS MODULE WILL
BE OVERWRITTEN BY THE TRANSPILER.
"""

import asyncio
import json
from typing import Annotated, Any

import httpx

from arcade_tdk import tool, ToolContext


# Retry configuration
INITIAL_RETRY_DELAY = 0.5  # seconds

HTTP_CLIENT = httpx.AsyncClient(
    timeout=httpx.Timeout(60.0, connect=10.0),
    limits=httpx.Limits(max_keepalive_connections=20, max_connections=100),
    transport=httpx.AsyncHTTPTransport(retries=3),
    http2=True,
    follow_redirects=True,
)


def remove_none_values(data: dict[str, Any]) -> dict[str, Any]:
    return {k: v for k, v in data.items() if v is not None}


async def make_request(
    url: str,
    method: str,
    params: dict[str, Any] | None = None,
    headers: dict[str, Any] | None = None,
    content: str | None = None,
    data: dict[str, Any] | None = None,
    auth: tuple[str, str] | None = None,
    max_retries: int = 3,
) -> httpx.Response:
    """Make an HTTP request with retry logic for 5xx server errors."""
    for attempt in range(max_retries):
        try:
            response = await HTTP_CLIENT.request(
                url=url,
                auth=auth,
                method=method,
                params=params,
                headers=headers,
                content=content,
            )
            response.raise_for_status()
        except httpx.HTTPStatusError as e:
            # Only retry on 5xx server errors
            if e.response.status_code >= 500 and attempt < max_retries - 1:
                # Exponential backoff: 0.5s, 1s, 2s
                await asyncio.sleep(INITIAL_RETRY_DELAY * (2**attempt))
                continue
            # Re-raise for 4xx errors or if max retries reached
            raise
        except httpx.RequestError as e:
            # Don't retry request errors (network issues are handled by transport)
            raise
        else:
            return response

    # This should never be reached, but satisfies type checker
    raise httpx.RequestError("Max retries exceeded")  # noqa: TRY003


@tool(requires_secrets=["ENTRATA_API_KEY", "ENTRATA_DOMAIN"])
async def check_api_health(
    context: ToolContext,
    authentication_type: Annotated[
        str, "The authentication method used, typically 'apikey'."
    ],
    client_subdomain: Annotated[
        str, "The subdomain of the client organization to check the API health for."
    ],
    method_name: Annotated[
        str, "The method name for the API operation. Use 'getStatus' to check health."
    ],
    api_method_version: Annotated[
        str | None,
        "Specify the version of the API method to use. The default and only supported value is 'r1'.",  # noqa: E501
    ] = None,
    response_identifier: Annotated[
        str | None,
        "An arbitrary string value to link the request with its corresponding response.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Check the health status of the API service.

    Use this tool to verify the current health status of the API service. This can help in determining if the service is operational and responsive."""  # noqa: E501
    request_data: Any = {
        "auth": {"type": authentication_type},
        "requestId": response_identifier,
        "method": {"name": method_name, "version": api_method_version},
    }
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://apis.{ENTRATA_DOMAIN}/ext/orgs/{orgs}/v1/status".format(  # noqa: UP032
            entrata_domain=context.get_secret("ENTRATA_DOMAIN"), orgs=client_subdomain
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Content-Type": "application/json",
                "X-Api-Key": context.get_secret("ENTRATA_API_KEY"),
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["ENTRATA_API_KEY", "ENTRATA_DOMAIN"])
async def submit_application(
    context: ToolContext,
    application_data: Annotated[
        list[dict[str, str]],
        "JSON array containing the application details to be submitted. Include all necessary information relevant to the application.",  # noqa: E501
    ],
    client_subdomain: Annotated[
        str, "The subdomain of the client to which the application is submitted."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Submit an application to the specified organization.

    This tool is used to submit applications to a specified organization using the Entrata service. It should be called when an application needs to be sent for processing."""  # noqa: E501
    request_data: Any = application_data
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://apis.{ENTRATA_DOMAIN}/ext/orgs/{orgs}/v1/applications".format(  # noqa: UP032
            entrata_domain=context.get_secret("ENTRATA_DOMAIN"), orgs=client_subdomain
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Content-Type": "application/json",
                "X-Api-Key": context.get_secret("ENTRATA_API_KEY"),
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["ENTRATA_API_KEY", "ENTRATA_DOMAIN"])
async def get_accessible_clients(
    context: ToolContext,
    organization_subdomain: Annotated[
        str,
        "The subdomain of the client organization. Use 'rsync' as the value to access relevant client information.",  # noqa: E501
    ],
    request_body_data: Annotated[
        list[dict[str, str]],
        "An array of JSON objects to include in the request body for additional data required by the API.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve accessible client information for a given organization.

    Use this tool to get information about clients accessible to an organization. Call it when you need to retrieve details about clients linked to the organization using the `rsync` value for `orgs`."""  # noqa: E501
    request_data: Any = request_body_data
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://apis.{ENTRATA_DOMAIN}/ext/orgs/{orgs}/v1/appinfo".format(  # noqa: UP032
            entrata_domain=context.get_secret("ENTRATA_DOMAIN"),
            orgs=organization_subdomain,
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Content-Type": "application/json",
                "X-Api-Key": context.get_secret("ENTRATA_API_KEY"),
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["ENTRATA_API_KEY", "ENTRATA_DOMAIN"])
async def get_ar_codes(
    context: ToolContext,
    ar_codes_method_name: Annotated[
        str,
        "Must be set to 'getArCodes' to specify the API method for retrieving AR codes.",  # noqa: E501
    ],
    authentication_type: Annotated[
        str, "Specify the authentication type, expected value is 'apikey'."
    ],
    client_subdomain: Annotated[
        str, "Client subdomain, used to specify the management company."
    ],
    api_method_version: Annotated[
        str | None,
        "Specifies the version of the API method to use. Supported value is 'r1'.",
    ] = None,
    property_id: Annotated[
        int | None,
        "Optional. Provide a valid property ID for which AR codes are required.",
    ] = None,
    response_identifier: Annotated[
        str | None,
        "An arbitrary string value used to relate the request with the response.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve AR codes for a management company.

    Fetches all AR codes associated with a specific management company, useful for property management and financial operations."""  # noqa: E501
    request_data: Any = {
        "auth": {"type": authentication_type},
        "requestId": response_identifier,
        "method": {
            "name": ar_codes_method_name,
            "version": api_method_version,
            "params": {"propertyId": property_id},
        },
    }
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://apis.{ENTRATA_DOMAIN}/ext/orgs/{orgs}/v1/arcodes".format(  # noqa: UP032
            entrata_domain=context.get_secret("ENTRATA_DOMAIN"), orgs=client_subdomain
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Content-Type": "application/json",
                "X-Api-Key": context.get_secret("ENTRATA_API_KEY"),
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["ENTRATA_API_KEY", "ENTRATA_DOMAIN"])
async def submit_ar_payments(
    context: ToolContext,
    authentication_type: Annotated[
        str, "Set the type of authentication. Accepted value: 'apikey'."
    ],
    client_subdomain: Annotated[
        str, "The subdomain of the client organization using the Entrata service."
    ],
    method_name_for_ar_payments: Annotated[
        str,
        "Specifies the method name for accounts receivable payments. Use 'getArPayments' to retrieve AR payments.",  # noqa: E501
    ],
    api_version: Annotated[
        str | None, "Specify the version of the API to use, options: ['r1']."
    ] = None,
    ar_payment_ids: Annotated[
        str | None,
        "Optional. Comma-separated list of accounts receivable payment IDs for processing.",  # noqa: E501
    ] = None,
    from_date: Annotated[
        str | None,
        "Optional. Accepts a single date value that represents the starting point for the query in YYYY-MM-DD format.",  # noqa: E501
    ] = None,
    include_allocations: Annotated[
        int | None,
        "Optional. Set to 1 to include allocations details of payment; 0 otherwise.",
    ] = None,
    payment_status_type_identifiers: Annotated[
        str | None, "Optional. Comma-separated IDs representing payment status types."
    ] = None,
    response_correlation_id: Annotated[
        str | None, "An arbitrary value used to correlate and track the response."
    ] = None,
    to_date: Annotated[
        str | None,
        "Optional field specifying the end date for the request. Accepts a single date value.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Submits accounts receivable payments for processing.

    Use this tool to submit accounts receivable payments to Entrata for processing. It confirms the successful submission of payment data."""  # noqa: E501
    request_data: Any = {
        "auth": {"type": authentication_type},
        "requestId": response_correlation_id,
        "method": {
            "name": method_name_for_ar_payments,
            "version": api_version,
            "params": {
                "arPaymentIds": ar_payment_ids,
                "paymentStatusTypeIds": payment_status_type_identifiers,
                "fromDate": from_date,
                "toDate": to_date,
                "isIncludeAllocations": include_allocations,
            },
        },
    }
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://apis.{ENTRATA_DOMAIN}/ext/orgs/{orgs}/v1/arpayments".format(  # noqa: UP032
            entrata_domain=context.get_secret("ENTRATA_DOMAIN"), orgs=client_subdomain
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Content-Type": "application/json",
                "X-Api-Key": context.get_secret("ENTRATA_API_KEY"),
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["ENTRATA_API_KEY", "ENTRATA_DOMAIN"])
async def get_ar_transactions(
    context: ToolContext,
    ar_transactions_request_body: Annotated[
        list[dict[str, str]],
        "Specify the array of transaction-related API request data in JSON format.",
    ],
    client_subdomain: Annotated[
        str,
        "The unique subdomain identifying the client organization for which the accounts receivable transactions are being fetched.",  # noqa: E501
    ],
    include_pagination_links: Annotated[
        int | None,
        "Set to 1 to include pagination links in the response body, 0 to exclude.",
    ] = None,
    items_per_page: Annotated[
        int | None,
        "Specifies the number of items returned in the response for each page of pagination.",  # noqa: E501
    ] = None,
    page_number: Annotated[
        int | None, "The page number to retrieve for paginated responses."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Fetches accounts receivable transactions for an organization.

    Use this tool to retrieve accounts receivable transactions by providing the organization identifier."""  # noqa: E501
    request_data: Any = ar_transactions_request_body
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://apis.{ENTRATA_DOMAIN}/ext/orgs/{orgs}/v1/artransactions".format(  # noqa: UP032
            entrata_domain=context.get_secret("ENTRATA_DOMAIN"), orgs=client_subdomain
        ),
        method="POST",
        params=remove_none_values({"page_no": page_number, "per_page": items_per_page}),
        headers=remove_none_values(
            {
                "Content-Type": "application/json",
                "X-Send-Pagination-Links": include_pagination_links,
                "X-Api-Key": context.get_secret("ENTRATA_API_KEY"),
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["ENTRATA_API_KEY", "ENTRATA_DOMAIN"])
async def send_communication_message(
    context: ToolContext,
    client_subdomain: Annotated[
        str,
        "The subdomain of the client organization where the communication message will be sent.",  # noqa: E501
    ],
    communication_messages_payload: Annotated[
        list[dict[str, str]],
        "JSON array containing details for arPayment-related communications.",
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Send communication messages via the Entrata Communications API.

    This tool sends communication messages using the Entrata Communications API. It should be called when a user wants to send a message to a specified organization. The tool performs a POST request to the specified endpoint to deliver the message and receives a confirmation of the communication being sent."""  # noqa: E501
    request_data: Any = communication_messages_payload
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://apis.{ENTRATA_DOMAIN}/ext/orgs/{orgs}/v1/communications".format(  # noqa: UP032
            entrata_domain=context.get_secret("ENTRATA_DOMAIN"), orgs=client_subdomain
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Content-Type": "application/json",
                "X-Api-Key": context.get_secret("ENTRATA_API_KEY"),
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["ENTRATA_API_KEY", "ENTRATA_DOMAIN"])
async def create_customer_profile(
    context: ToolContext,
    client_subdomain: Annotated[
        str, "The unique subdomain of the client organization in the Entrata system."
    ],
    customer_payment_info: Annotated[
        list[dict[str, str]],
        "A JSON array containing AR payment-related information for the customer profile creation.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Create a new customer profile in the Entrata system.

    Use this tool to add a new customer profile to the Entrata database for a specific organization. Useful for handling customer onboarding processes."""  # noqa: E501
    request_data: Any = customer_payment_info
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://apis.{ENTRATA_DOMAIN}/ext/orgs/{orgs}/v1/customers".format(  # noqa: UP032
            entrata_domain=context.get_secret("ENTRATA_DOMAIN"), orgs=client_subdomain
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Content-Type": "application/json",
                "X-Api-Key": context.get_secret("ENTRATA_API_KEY"),
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["ENTRATA_API_KEY", "ENTRATA_DOMAIN"])
async def get_financial_budgets(
    context: ToolContext,
    ar_payment_requests: Annotated[
        list[dict[str, str]],
        "A list of JSON objects representing AR payment related data for processing. Each JSON object should contain details as required by the specific AR payment APIs.",  # noqa: E501
    ],
    client_subdomain: Annotated[
        str,
        "The subdomain of the client organization for which to fetch financial budgets.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Fetch financial budgets for organizations.

    Use this tool to retrieve financial budget data for specified organizations through the Entrata service. Supports pagination for large data sets."""  # noqa: E501
    request_data: Any = ar_payment_requests
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://apis.{ENTRATA_DOMAIN}/ext/orgs/{orgs}/v1/financial".format(  # noqa: UP032
            entrata_domain=context.get_secret("ENTRATA_DOMAIN"), orgs=client_subdomain
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Content-Type": "application/json",
                "X-Api-Key": context.get_secret("ENTRATA_API_KEY"),
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["ENTRATA_API_KEY", "ENTRATA_DOMAIN"])
async def create_lead_entry(
    context: ToolContext,
    client_subdomain: Annotated[
        str, "The subdomain associated with the client organization in Entrata."
    ],
    lead_information: Annotated[
        list[dict[str, str]],
        "An array of JSON objects representing the new lead's details to be added. Each JSON object should contain properties relevant to the lead, such as name, contact information, and any other required fields.",  # noqa: E501
    ],
    include_pagination_links: Annotated[
        int | None,
        "Flag to include pagination links in the response body. Use '1' to enable and '0' to disable.",  # noqa: E501
    ] = None,
    number_of_items_per_page: Annotated[
        int | None,
        "Specify the number of items to be returned per page in the paginated response.",  # noqa: E501
    ] = None,
    page_number: Annotated[
        int | None,
        "The page number for paginated responses. Use this to specify which page to retrieve when dealing with paginated data.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Create a new lead entry in the Entrata system.

    Use this tool to submit a new lead's information to the Entrata system for a specified organization. This action is suitable when new leads need to be captured and stored in the system for follow-up or record-keeping."""  # noqa: E501
    request_data: Any = lead_information
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://apis.{ENTRATA_DOMAIN}/ext/orgs/{orgs}/v1/leads".format(  # noqa: UP032
            entrata_domain=context.get_secret("ENTRATA_DOMAIN"), orgs=client_subdomain
        ),
        method="POST",
        params=remove_none_values(
            {"page_no": page_number, "per_page": number_of_items_per_page}
        ),
        headers=remove_none_values(
            {
                "Content-Type": "application/json",
                "X-Send-Pagination-Links": include_pagination_links,
                "X-Api-Key": context.get_secret("ENTRATA_API_KEY"),
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["ENTRATA_API_KEY", "ENTRATA_DOMAIN"])
async def get_lease_details(
    context: ToolContext,
    client_subdomain: Annotated[
        str,
        "The subdomain representing the client organization. Required to specify which client's data to retrieve.",  # noqa: E501
    ],
    lease_documents_upload: Annotated[
        list[dict[str, str]],
        "Upload lease documents using a form file upload (multipart/form-data).",
    ],
    include_pagination_links: Annotated[
        int | None,
        "Set to 1 to include pagination links in the response. Use 0 to exclude them. This helps manage paginated data effectively.",  # noqa: E501
    ] = None,
    items_per_page: Annotated[
        int | None,
        "The number of items to return per page in the response. Supports paginated data retrieval.",  # noqa: E501
    ] = None,
    page_number: Annotated[
        int | None,
        "The page number to retrieve in a paginated response. Use this to navigate through pages of lease details.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve detailed information about leases.

    Use this tool to get detailed information about leases, including lease activities, details, documents, parcels, and more. It supports pagination for handling large datasets."""  # noqa: E501
    request_data: Any = lease_documents_upload
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://apis.{ENTRATA_DOMAIN}/ext/orgs/{orgs}/v1/leases".format(  # noqa: UP032
            entrata_domain=context.get_secret("ENTRATA_DOMAIN"), orgs=client_subdomain
        ),
        method="POST",
        params=remove_none_values({"page_no": page_number, "per_page": items_per_page}),
        headers=remove_none_values(
            {
                "Content-Type": "application/json",
                "X-Send-Pagination-Links": include_pagination_links,
                "X-Api-Key": context.get_secret("ENTRATA_API_KEY"),
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["ENTRATA_API_KEY", "ENTRATA_DOMAIN"])
async def leasing_center_call_logs(
    context: ToolContext,
    client_subdomain: Annotated[
        str,
        "The subdomain of the client organization. This is required to identify the client's data for retrieving call logs.",  # noqa: E501
    ],
    request_body_payload: Annotated[
        list[dict[str, str]],
        "An array of JSON objects to be included in the request. Typically used for specifying additional data or filters for the API call.",  # noqa: E501
    ],
    include_pagination_links: Annotated[
        int | None,
        "Set to 1 to include pagination links in the response; set to 0 to exclude them.",  # noqa: E501
    ] = None,
    items_per_page: Annotated[
        int | None,
        "Number of items to return per page in the response. Use for pagination.",
    ] = None,
    page_number: Annotated[
        int | None,
        "The page number to retrieve in a paginated response from the leasing center call logs.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve leasing center call logs for analysis.

    Use this tool to access call logs from the leasing center, supporting pagination for detailed data retrieval."""  # noqa: E501
    request_data: Any = request_body_payload
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://apis.{ENTRATA_DOMAIN}/ext/orgs/{orgs}/v1/leasingcenter".format(  # noqa: UP032
            entrata_domain=context.get_secret("ENTRATA_DOMAIN"), orgs=client_subdomain
        ),
        method="POST",
        params=remove_none_values({"page_no": page_number, "per_page": items_per_page}),
        headers=remove_none_values(
            {
                "Content-Type": "application/json",
                "X-Send-Pagination-Links": include_pagination_links,
                "X-Api-Key": context.get_secret("ENTRATA_API_KEY"),
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["ENTRATA_API_KEY", "ENTRATA_DOMAIN"])
async def request_maintenance_service(
    context: ToolContext,
    client_subdomain: Annotated[
        str,
        "The unique subdomain identifier for the client organization requesting the service.",  # noqa: E501
    ],
    maintenance_request_details: Annotated[
        list[dict[str, str]],
        "The JSON array containing details required to initiate a maintenance request. Include all necessary fields as per Entrata's API requirements.",  # noqa: E501
    ],
    include_pagination_links: Annotated[
        int | None,
        "Set to 1 to include pagination links in the response body, otherwise set to 0.",  # noqa: E501
    ] = None,
    items_per_page: Annotated[
        int | None, "Specifies the number of items to return per page in the response."
    ] = None,
    page_number: Annotated[
        int | None,
        "The page number for paginated responses. Use to retrieve a specific page in a paginated series.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Request maintenance services for an organization.

    This tool calls the Entrata API to request maintenance services for a specified organization. It should be used when an entity needs to initiate a new maintenance service order."""  # noqa: E501
    request_data: Any = maintenance_request_details
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://apis.{ENTRATA_DOMAIN}/ext/orgs/{orgs}/v1/maintenance".format(  # noqa: UP032
            entrata_domain=context.get_secret("ENTRATA_DOMAIN"), orgs=client_subdomain
        ),
        method="POST",
        params=remove_none_values({"page_no": page_number, "per_page": items_per_page}),
        headers=remove_none_values(
            {
                "Content-Type": "application/json",
                "X-Send-Pagination-Links": include_pagination_links,
                "X-Api-Key": context.get_secret("ENTRATA_API_KEY"),
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["ENTRATA_API_KEY", "ENTRATA_DOMAIN"])
async def update_pricing(
    context: ToolContext,
    client_subdomain: Annotated[
        str,
        "The subdomain associated with the client organization for which pricing is being updated.",  # noqa: E501
    ],
    pricing_update_details: Annotated[
        list[dict[str, str]],
        "A JSON array containing the details for pricing updates. Each element should include specifics like product ID, new price, and effective date.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Update pricing information for a specified organization.

    Use this tool to adjust the pricing details for an organization. This is typically called when changes in pricing need to be implemented for specific organizational needs or market conditions."""  # noqa: E501
    request_data: Any = pricing_update_details
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://apis.{ENTRATA_DOMAIN}/ext/orgs/{orgs}/v1/pricing".format(  # noqa: UP032
            entrata_domain=context.get_secret("ENTRATA_DOMAIN"), orgs=client_subdomain
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Content-Type": "application/json",
                "X-Api-Key": context.get_secret("ENTRATA_API_KEY"),
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["ENTRATA_API_KEY", "ENTRATA_DOMAIN"])
async def get_property_details(
    context: ToolContext,
    client_subdomain: Annotated[
        str,
        "The subdomain representing the specific client or organization for which property details are requested.",  # noqa: E501
    ],
    property_request_body: Annotated[
        list[dict[str, str]],
        "The JSON array containing the request details for fetching property information. This should include any necessary filters or criteria.",  # noqa: E501
    ],
    include_pagination_links: Annotated[
        int | None,
        "Set to 1 to include pagination links in the response; 0 to exclude them.",
    ] = None,
    items_per_page: Annotated[
        int | None, "Number of items to return per page in the response."
    ] = None,
    page_number: Annotated[
        int | None, "The current page number to retrieve in a paginated response."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve details of properties for a specific organization.

    This tool accesses property details for a specific organization using the Entrata API. It should be called when detailed property information is needed, such as for property management or listings."""  # noqa: E501
    request_data: Any = property_request_body
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://apis.{ENTRATA_DOMAIN}/ext/orgs/{orgs}/v1/properties".format(  # noqa: UP032
            entrata_domain=context.get_secret("ENTRATA_DOMAIN"), orgs=client_subdomain
        ),
        method="POST",
        params=remove_none_values({"page_no": page_number, "per_page": items_per_page}),
        headers=remove_none_values(
            {
                "Content-Type": "application/json",
                "X-Send-Pagination-Links": include_pagination_links,
                "X-Api-Key": context.get_secret("ENTRATA_API_KEY"),
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["ENTRATA_API_KEY", "ENTRATA_DOMAIN"])
async def create_property_unit(
    context: ToolContext,
    client_subdomain: Annotated[
        str,
        "The subdomain of the client organization where the property unit should be added.",  # noqa: E501
    ],
    property_unit_details: Annotated[
        list[dict[str, str]],
        "A JSON array containing the details of the property unit to be created, such as unit identifier, size, and location.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Add a new property unit to the system.

    This tool creates a new property unit within the specified organization. It should be called when there is a need to register or add information about a new unit in a property management system."""  # noqa: E501
    request_data: Any = property_unit_details
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://apis.{ENTRATA_DOMAIN}/ext/orgs/{orgs}/v1/propertyunits".format(  # noqa: UP032
            entrata_domain=context.get_secret("ENTRATA_DOMAIN"), orgs=client_subdomain
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Content-Type": "application/json",
                "X-Api-Key": context.get_secret("ENTRATA_API_KEY"),
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["ENTRATA_API_KEY", "ENTRATA_DOMAIN"])
async def get_vendors(
    context: ToolContext,
    organization_subdomain: Annotated[
        str, "The subdomain representing the organization to retrieve vendors for."
    ],
    vendor_request_body: Annotated[
        list[dict[str, str]],
        "Provide the request body as a JSON array for fetching vendor data. This should include any necessary parameters required by the API to process the vendor data request.",  # noqa: E501
    ],
    include_pagination_links: Annotated[
        int | None,
        "Set to 1 to include pagination links in the response body, 0 to exclude.",
    ] = None,
    items_per_page: Annotated[
        int | None,
        "The number of items to return per page in the response for pagination.",
    ] = None,
    page_number: Annotated[
        int | None, "The page number for pagination of the vendor list."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve a list of vendors for a given organization.

    This tool fetches vendor information from Entrata for a specified organization. Use it to obtain a comprehensive list of vendors associated with an organization ID."""  # noqa: E501
    request_data: Any = vendor_request_body
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://apis.{ENTRATA_DOMAIN}/ext/orgs/{orgs}/v1/vendors".format(  # noqa: UP032
            entrata_domain=context.get_secret("ENTRATA_DOMAIN"),
            orgs=organization_subdomain,
        ),
        method="POST",
        params=remove_none_values({"page_no": page_number, "per_page": items_per_page}),
        headers=remove_none_values(
            {
                "Content-Type": "application/json",
                "X-Send-Pagination-Links": include_pagination_links,
                "X-Api-Key": context.get_secret("ENTRATA_API_KEY"),
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}

