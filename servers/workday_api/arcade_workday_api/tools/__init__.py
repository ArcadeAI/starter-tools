"""Arcade Starter Tools for Workday

DO NOT EDIT THIS MODULE DIRECTLY.

THIS MODULE WAS AUTO-GENERATED BY TRANSPILING THE API STARTER TOOL JSON DEFINITIONS
IN THE ../wrapper_tools DIRECTORY INTO PYTHON CODE. ANY CHANGES TO THIS MODULE WILL
BE OVERWRITTEN BY THE TRANSPILER.
"""

import asyncio
import json
import jsonschema
from enum import Enum
from typing import Annotated, Any

import httpx

from arcade_tdk import tool, ToolContext
from arcade_tdk.errors import RetryableToolError
from arcade_tdk.auth import OAuth2

from .request_body_schemas import REQUEST_BODY_SCHEMAS

# Retry configuration
INITIAL_RETRY_DELAY = 0.5  # seconds

HTTP_CLIENT = httpx.AsyncClient(
    timeout=httpx.Timeout(60.0, connect=10.0),
    limits=httpx.Limits(max_keepalive_connections=20, max_connections=100),
    transport=httpx.AsyncHTTPTransport(retries=3),
    http2=True,
    follow_redirects=True,
)


class ToolMode(str, Enum):
    """Mode for tools with complex request bodies."""

    GET_REQUEST_SCHEMA = "get_request_schema"
    EXECUTE = "execute"


def remove_none_values(data: dict[str, Any]) -> dict[str, Any]:
    return {k: v for k, v in data.items() if v is not None}


async def make_request(
    url: str,
    method: str,
    params: dict[str, Any] | None = None,
    headers: dict[str, Any] | None = None,
    content: str | None = None,
    data: dict[str, Any] | None = None,
    auth: tuple[str, str] | None = None,
    max_retries: int = 3,
) -> httpx.Response:
    """Make an HTTP request with retry logic for 5xx server errors."""
    for attempt in range(max_retries):
        try:
            response = await HTTP_CLIENT.request(
                url=url,
                auth=auth,
                method=method,
                params=params,
                headers=headers,
                content=content,
            )
            response.raise_for_status()
        except httpx.HTTPStatusError as e:
            # Only retry on 5xx server errors
            if e.response.status_code >= 500 and attempt < max_retries - 1:
                # Exponential backoff: 0.5s, 1s, 2s
                await asyncio.sleep(INITIAL_RETRY_DELAY * (2**attempt))
                continue
            # Re-raise for 4xx errors or if max retries reached
            raise
        except httpx.RequestError as e:
            # Don't retry request errors (network issues are handled by transport)
            raise
        else:
            return response

    # This should never be reached, but satisfies type checker
    raise httpx.RequestError("Max retries exceeded")  # noqa: TRY003


async def make_request_with_schema_validation(
    url: str,
    method: str,
    request_data: dict[str, Any],
    schema: dict[str, Any] | str,
    auth: tuple[str, str] | None = None,
    params: dict[str, Any] | None = None,
    headers: dict[str, Any] | None = None,
    max_retries: int = 3,
) -> httpx.Response:
    """Make an HTTP request with schema validation on format errors."""
    # Parse schema if it's a string, skip validation if parsing fails
    parsed_schema = None
    if isinstance(schema, str):
        try:
            parsed_schema = json.loads(schema)
        except Exception:
            # If schema parsing fails, just skip validation
            parsed_schema = None
    else:
        parsed_schema = schema

    try:
        response = await make_request(
            url=url,
            auth=auth,
            method=method,
            params=params,
            headers=headers,
            content=json.dumps(request_data),
            max_retries=max_retries,
        )
    except httpx.HTTPStatusError as e:
        # Only provide schema validation for format-related errors
        if e.response.status_code in (400, 422):
            api_error_details = (
                f"API returned {e.response.status_code}: {e.response.text}"
            )

            # Only run validation if we have a valid parsed schema
            if parsed_schema is not None:
                # Run validation to provide additional context
                is_valid, validation_error = validate_json_against_schema(
                    request_data, parsed_schema
                )

                if not is_valid:
                    # Schema validation found issues - additional context
                    additional_context = (
                        f"{api_error_details}\n\n"
                        f"Schema validation found the following issues:\n"
                        f"{validation_error}"
                    )
                else:
                    # Schema validation passed - just show API error
                    additional_context = api_error_details
            else:
                # No valid schema - just show API error
                additional_context = api_error_details

            raise RetryableToolError(
                message=(
                    f"API request failed with validation error: "
                    f"{e.response.status_code}"
                ),
                developer_message=api_error_details,
                additional_prompt_content=additional_context,
            ) from e
        else:
            # For non-validation errors, re-raise as-is
            raise
    else:
        return response


def validate_json_against_schema(
    json_data: dict[str, Any], schema: dict[str, Any]
) -> tuple[bool, str | None]:
    """Validate JSON data against an OpenAPI/JSON Schema.

    This provides full JSON Schema Draft 7 validation including:
    - Required fields, types, enums
    - Pattern validation (regex)
    - Format validation (email, uuid, date-time, etc.)
    - Min/max length and values
    - oneOf, anyOf, allOf
    - And all other JSON Schema features

    Args:
        json_data: The JSON data to validate
        schema: The JSON Schema to validate against

    Returns:
        Tuple of (is_valid, error_messages). If valid, error_messages is None.
        If invalid, error_messages contains all validation errors.
    """
    try:
        validator = jsonschema.Draft7Validator(
            schema, format_checker=jsonschema.Draft7Validator.FORMAT_CHECKER
        )
        # Collect ALL validation errors
        errors = list(validator.iter_errors(json_data))
        if errors:
            # Format all errors with their paths
            error_messages = []
            for error in errors:
                error_path = (
                    ".".join(str(p) for p in error.path) if error.path else "root"
                )
                error_messages.append(f"{error.message} at {error_path}")
            # Join all errors with newlines
            return False, "\n".join(error_messages)
        else:
            return True, None
    except jsonschema.SchemaError as e:
        return False, f"Invalid schema: {e.message}"
    except Exception as e:
        return False, f"Validation error: {e!s}"


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def get_scorecard_results(
    context: ToolContext,
    maximum_objects_per_response: Annotated[
        int | None,
        "The maximum number of objects to retrieve in a single response. Defaults to 20, with a max of 100.",  # noqa: E501
    ] = None,
    response_offset_index: Annotated[
        int | None,
        "The zero-based index of the first object in a response collection, used for response paging. Default is 0.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve scorecard results for advanced compensation.

    This tool retrieves scorecard results as part of the advanced compensation module, secured by Set Up: Merit and Bonus."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/compensation/v2/scorecardResults".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL")
        ),
        method="GET",
        params=remove_none_values(
            {"limit": maximum_objects_per_response, "offset": response_offset_index}
        ),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def submit_compensation_scorecard_result(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Submit a Compensation Scorecard result for evaluation.

    Use this tool to submit a Compensation Scorecard result with a specified evaluation date in 'yyyy-mm-dd' format. Ensure you have the Workday ID from a Compensation Scorecard. This is secured by 'Set Up: Merit and Bonus' and requires the 'Advanced Compensation' scope.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS[
                "SUBMITCOMPENSATIONSCORECARDRESULT"
            ],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["SUBMITCOMPENSATIONSCORECARDRESULT"]
                + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["SUBMITCOMPENSATIONSCORECARDRESULT"]
                + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="{workday_base_url}/compensation/v2/scorecardResults".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL")
        ),
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["SUBMITCOMPENSATIONSCORECARDRESULT"],
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Content-Type": "application/json",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }
        ),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def get_compensation_scorecard_info(
    context: ToolContext,
    effective_date_for_scorecard: Annotated[
        str | None,
        "Effective date the scorecard task takes effect, formatted as a string (e.g., 'YYYY-MM-DD').",  # noqa: E501
    ] = None,
    maximum_results_limit: Annotated[
        int | None,
        "The maximum number of objects in a single response, up to 100. Default is 20 if not specified.",  # noqa: E501
    ] = None,
    response_start_index: Annotated[
        int | None,
        "The zero-based index of the first object in the response collection. Default is 0. Use with 'limit' to manage paging. E.g., if 'limit' is 5 and 'offset' is 9, the response starts with the 10th object.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Fetches compensation scorecard information from Workday.

    Call this tool to retrieve detailed information about compensation scorecards, including name, description, status, default goals, and related profiles as of a specific effective date. Useful for exploring advanced compensation data."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/compensation/v2/scorecards".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL")
        ),
        method="GET",
        params=remove_none_values(
            {
                "effectiveDate": effective_date_for_scorecard,
                "limit": maximum_results_limit,
                "offset": response_start_index,
            }
        ),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def create_compensation_scorecard(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Create a new compensation scorecard in Workday.

    This tool creates a new compensation scorecard using required fields like scorecardName, effectiveDate, and defaultScorecardGoals. Optional scorecardProfiles with eligibility rules and profileScorecardGoals can also be specified. It is used within the Advanced Compensation scope and requires the Merit and Bonus setup.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["CREATECOMPENSATIONSCORECARD"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["CREATECOMPENSATIONSCORECARD"]
                + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["CREATECOMPENSATIONSCORECARD"]
                + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="{workday_base_url}/compensation/v2/scorecards".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL")
        ),
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["CREATECOMPENSATIONSCORECARD"],
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Content-Type": "application/json",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }
        ),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def get_worker_instance(
    context: ToolContext,
    worker_id: Annotated[
        str, "The unique Workday ID of the worker whose details you want to retrieve."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve a worker's details using their unique ID.

    Use this tool to get detailed information about a specific worker by providing their unique ID. It accesses staffing data securely managed by Workday."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/compensation/v2/workers/{ID}".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL"), ID=worker_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def retrieve_scorecard_results(
    context: ToolContext,
    workday_id: Annotated[
        str, "The Workday ID of the resource to retrieve scorecard results for."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve scorecard results for a specific ID.

    This tool retrieves the scorecard results based on a provided ID within the Advanced Compensation scope. It is secured and requires the appropriate setup for Merit and Bonus access."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/compensation/v2/scorecardResults/{ID}".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL"), ID=workday_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def delete_scorecard_results(
    context: ToolContext,
    workday_resource_id: Annotated[
        str, "The unique Workday ID of the Scorecard Results to be deleted."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Deletes specified Scorecard Results by ID.

    Use this tool to delete the Scorecard Results with a given ID. It requires authorization under the Merit and Bonus setup in the scope of Advanced Compensation."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/compensation/v2/scorecardResults/{ID}".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL"),
            ID=workday_resource_id,
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def retrieve_workers(
    context: ToolContext,
    include_terminated_workers: Annotated[
        bool | None,
        "Set to true to include terminated workers in the results, false to exclude them.",  # noqa: E501
    ] = None,
    max_objects_per_response: Annotated[
        int | None,
        "The maximum number of worker records to retrieve per response. Defaults to 20, with a maximum of 100.",  # noqa: E501
    ] = None,
    starting_index_for_paging: Annotated[
        int | None,
        "The zero-based index for the first worker in the response. Default is 0. Useful for paginating results with the limit parameter.",  # noqa: E501
    ] = None,
    worker_search_name: Annotated[
        str | None,
        "A case-insensitive search term to filter workers by name. Leave empty to retrieve all workers.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve all workers or search by name.

    Use this tool to obtain a list of all workers or find specific workers by name. The search is case-insensitive and can be useful for managing or viewing staffing information."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/compensation/v2/workers".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL")
        ),
        method="GET",
        params=remove_none_values(
            {
                "includeTerminatedWorkers": include_terminated_workers,
                "limit": max_objects_per_response,
                "offset": starting_index_for_paging,
                "search": worker_search_name,
            }
        ),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def create_one_time_payment(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    worker_id: Annotated[
        str | None,
        "The Workday ID of the worker for whom the one-time payment is being initiated.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Initiates a one-time payment process for a specified worker.

    This tool is used to create a one-time payment for a worker by specifying necessary information such as reason, position, and payment details. It's part of the Request One-Time Payment business process in Core Compensation, secured by the REST service.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["CREATEONETIMEPAYMENT"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not worker_id:
        missing_params.append(("worker_id", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(
                f"Required parameters validation failed: {param_details}"
            ),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["CREATEONETIMEPAYMENT"]
                + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["CREATEONETIMEPAYMENT"]
                + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="{workday_base_url}/compensation/v2/workers/{ID}/requestOneTimePayment".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL"), ID=worker_id
        ),
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["CREATEONETIMEPAYMENT"],
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Content-Type": "application/json",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }
        ),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def set_scorecard_achievement_value(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    resource_id: Annotated[
        str | None,
        "The Workday ID of the resource to be updated.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    subresource_id: Annotated[
        str | None,
        "The unique Workday ID of the subresource. Required for identifying specific scorecard elements.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Set achievement percentage for a score in a scorecard.

    This tool updates the achievement value for a specific score in a scorecard result by setting it as a percentage (1-100%).

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["SETSCORECARDACHIEVEMENTVALUE"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not resource_id:
        missing_params.append(("resource_id", "path"))
    if not subresource_id:
        missing_params.append(("subresource_id", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(
                f"Required parameters validation failed: {param_details}"
            ),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["SETSCORECARDACHIEVEMENTVALUE"]
                + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["SETSCORECARDACHIEVEMENTVALUE"]
                + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="{workday_base_url}/compensation/v2/scorecardResults/{ID}/scores/{subresourceID}".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL"),
            ID=resource_id,
            subresourceID=subresource_id,
        ),
        method="PATCH",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["SETSCORECARDACHIEVEMENTVALUE"],
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Content-Type": "application/json",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }
        ),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def retrieve_compensation_scorecard(
    context: ToolContext,
    workday_resource_id: Annotated[
        str, "The Workday ID for the compensation scorecard resource."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Fetches details of a compensation scorecard.

    Retrieves details of a compensation scorecard, including the scorecard name, description, status, goals, and profiles as of a specific effective date."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/compensation/v2/scorecards/{ID}".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL"),
            ID=workday_resource_id,
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def update_compensation_scorecard(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    resource_workday_id: Annotated[
        str | None,
        "The unique Workday ID for the compensation scorecard to be updated.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Update an existing compensation scorecard.

    Use this tool to update an existing compensation scorecard as of a specified effective date. You can modify the scorecard name, description, inactive status, and manage goals and profiles within the scorecard. Ensure you fetch the current scorecard data first using GET /scorecards/{ID} to populate the request body with existing data.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["UPDATECOMPENSATIONSCORECARD"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not resource_workday_id:
        missing_params.append(("resource_workday_id", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(
                f"Required parameters validation failed: {param_details}"
            ),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["UPDATECOMPENSATIONSCORECARD"]
                + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["UPDATECOMPENSATIONSCORECARD"]
                + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="{workday_base_url}/compensation/v2/scorecards/{ID}".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL"),
            ID=resource_workday_id,
        ),
        method="PUT",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["UPDATECOMPENSATIONSCORECARD"],
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Content-Type": "application/json",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }
        ),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def delete_compensation_scorecard(
    context: ToolContext,
    compensation_scorecard_id: Annotated[
        str, "The unique Workday ID of the compensation scorecard to delete."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Delete a compensation scorecard by ID.

    Use this tool to delete a compensation scorecard identified by its ID in Workday. Ensure appropriate security and scope settings are in place before making this call."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/compensation/v2/scorecards/{ID}".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL"),
            ID=compensation_scorecard_id,
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def get_worker_time_attestation_followup(
    context: ToolContext,
    workday_resource_id: Annotated[
        str,
        "The unique Workday ID of the resource needed for fetching time attestation follow-up details.",  # noqa: E501
    ],
    maximum_response_objects: Annotated[
        int | None,
        "Specifies the maximum number of objects to return in a single response. Defaults to 20, maximum is 100.",  # noqa: E501
    ] = None,
    starting_index_of_response: Annotated[
        int | None,
        "Zero-based index of the first object in response. Defaults to 0. Use with 'max_objects_in_response' to control pagination.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Fetch follow-up details for a worker's time attestation.

    This tool retrieves follow-up information related to a worker's time attestation within the Workday system, using the Time Clock Event REST API. It should be called when specific time tracking information is needed for review or processing."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/timeTracking/v5/workerTimeAttestation/{ID}/followupWorkerTimeAttestation".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL"),
            ID=workday_resource_id,
        ),
        method="GET",
        params=remove_none_values(
            {"limit": maximum_response_objects, "offset": starting_index_of_response}
        ),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def get_time_entry_validations(
    context: ToolContext,
    max_objects_per_response: Annotated[
        int | None,
        "Specify the maximum number of objects to return in a single response. Default is 20; maximum is 100.",  # noqa: E501
    ] = None,
    response_offset_index: Annotated[
        int | None,
        "The zero-based index for the starting object in the response collection, used for paging.",  # noqa: E501
    ] = None,
    validation_date: Annotated[
        str | None,
        "The required date that determines the time entry validations. Format as YYYY-MM-DD.",  # noqa: E501
    ] = None,
    worker_id: Annotated[
        str | None,
        "The Workday ID of the worker whose time entries are being validated. This is a required parameter for the API call.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve time entry validations for a given worker and date.

    Use this tool to obtain a collection of time entry validation messages for a specific worker on a given date. It helps identify issues based on critical or warning custom validations configured in Workday's Maintain Time Entry Validations task. Requires worker ID and date as inputs."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/timeTracking/v5/timeValidations".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL")
        ),
        method="GET",
        params=remove_none_values(
            {
                "date": validation_date,
                "limit": max_objects_per_response,
                "offset": response_offset_index,
                "worker": worker_id,
            }
        ),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def get_time_entry_code_values(
    context: ToolContext,
    effective_date: Annotated[
        str | None,
        "The effective date to look up time types for a given worker. Format as YYYY-MM-DD.",  # noqa: E501
    ] = None,
    maximum_response_objects: Annotated[
        int | None,
        "Specifies the maximum number of objects in a single response. Default and max is 1000.",  # noqa: E501
    ] = None,
    paging_offset: Annotated[
        int | None,
        "The starting index for the response collection. Use this with 'limit' to control paging.",  # noqa: E501
    ] = None,
    project_id: Annotated[
        str | None, "The Workday ID of the project to filter project plan tasks."
    ] = None,
    return_in_out_time_entry_codes_only: Annotated[
        bool | None,
        "Set to true to return only Time Entry Codes of the type In/Out for POST Time Clock Event use.",  # noqa: E501
    ] = None,
    worker_id: Annotated[
        str | None,
        "The Workday ID of the worker to retrieve time entry code values for.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve available time entry code values from Workday.

    This tool fetches the time entry code values that can be used as parameters in other Workday API endpoints. Use it when you need to obtain valid time entry codes."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/timeTracking/v5/values/timeTypes/timeEntryCodes/".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL")
        ),
        method="GET",
        params=remove_none_values(
            {
                "date": effective_date,
                "inOutCodeOnly": return_in_out_time_entry_codes_only,
                "limit": maximum_response_objects,
                "offset": paging_offset,
                "project": project_id,
                "worker": worker_id,
            }
        ),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def get_position_values(
    context: ToolContext,
    effective_date_for_worker: Annotated[
        str | None,
        "The effective date to look up time values for a specific worker in Workday.",
    ] = None,
    max_response_objects: Annotated[
        int | None,
        "Specify the maximum number of objects to return in a single response. Default and max is 1000.",  # noqa: E501
    ] = None,
    response_collection_offset: Annotated[
        int | None,
        "The zero-based index of the first object in a response. Defaults to 0. Use with 'limit' for paging, e.g., limit=5 & offset=9 returns 5 items starting at the 10th.",  # noqa: E501
    ] = None,
    worker_id: Annotated[
        str | None, "The Workday ID of the worker for retrieving time values."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve available position values for endpoint parameters in Workday.

    Use this tool to get a list of position values that can be leveraged as parameters when interacting with other endpoints in the Workday service."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/timeTracking/v5/values/timeValues/positions/".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL")
        ),
        method="GET",
        params=remove_none_values(
            {
                "date": effective_date_for_worker,
                "limit": max_response_objects,
                "offset": response_collection_offset,
                "worker": worker_id,
            }
        ),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def get_time_tracking_time_types(
    context: ToolContext,
    end_date: Annotated[
        str | None,
        "End date for the time period the worker is creating a time entry for. Format expected: YYYY-MM-DD.",  # noqa: E501
    ] = None,
    maximum_response_objects: Annotated[
        int | None,
        "Specifies the maximum number of time types to return in the response. Maximum is 1000.",  # noqa: E501
    ] = None,
    response_start_index: Annotated[
        int | None,
        "Zero-based index of the first object in a response collection. Defaults to 0. Use with 'limit' for paging.",  # noqa: E501
    ] = None,
    start_date_for_time_entry: Annotated[
        str | None, "Start date for the worker's time entry period. Format: YYYY-MM-DD."
    ] = None,
    worker_identifier: Annotated[
        str | None,
        "The unique identifier for the worker for whom the Time Type data is needed.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve nested prompt structure for Time Tracking Time Types.

    Use this tool to obtain a structured prompt for Time Tracking Time Types, mirroring the layout used in UI prompts. Note that this does not include Time Offs."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/timeTracking/v5/values/enterTimeByType/timeTypeNested/".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL")
        ),
        method="GET",
        params=remove_none_values(
            {
                "endDate": end_date,
                "limit": maximum_response_objects,
                "offset": response_start_index,
                "startDate": start_date_for_time_entry,
                "worker": worker_identifier,
            }
        ),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def retrieve_time_entry_values(
    context: ToolContext,
    effective_date: Annotated[
        str | None,
        "The effective date to look up time types for a given worker. Format as 'YYYY-MM-DD'.",  # noqa: E501
    ] = None,
    maximum_response_objects: Annotated[
        int | None,
        "Specifies the maximum number of objects to include in a single response, with a default and maximum value of 1000.",  # noqa: E501
    ] = None,
    project_id: Annotated[
        str | None,
        "The Workday ID of a project used to filter tasks from a specific project.",
    ] = None,
    response_offset_index: Annotated[
        int | None,
        "The zero-based index of the first object in the response collection used to control paging. Default is 0.",  # noqa: E501
    ] = None,
    return_only_in_out_codes: Annotated[
        bool | None,
        "Set to true to return only Time Entry Codes of the type In/Out. Use with POST Time Clock Event.",  # noqa: E501
    ] = None,
    worker_id: Annotated[
        str | None,
        "The Workday ID of the worker to look up time types for. This is used to retrieve specific data related to the worker.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve time entry code values for Workday APIs.

    Use this tool to get time entry code instances that can be used in Workday API calls as parameter values. It ensures you have the correct instances needed for further API interactions."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/timeTracking/v5/values/timeTypes/defaultTimeEntryCode/".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL")
        ),
        method="GET",
        params=remove_none_values(
            {
                "date": effective_date,
                "inOutCodeOnly": return_only_in_out_codes,
                "limit": maximum_response_objects,
                "offset": response_offset_index,
                "project": project_id,
                "worker": worker_id,
            }
        ),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def create_worker_time_block(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    workday_resource_id: Annotated[
        str | None,
        "The Workday ID of the specific worker resource to create a time block for.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Creates a worker time block in Workday.

    Use this tool to create a time block for a specified worker in the Workday system. This is useful for recording working hours, whether hourly or in certain time zones, for project-related tasks. Ensure to include necessary details like calendar date, in/out times, and select one from time entry code, project, or project plan task.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["CREATEWORKERTIMEBLOCK"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not workday_resource_id:
        missing_params.append(("workday_resource_id", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(
                f"Required parameters validation failed: {param_details}"
            ),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["CREATEWORKERTIMEBLOCK"]
                + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["CREATEWORKERTIMEBLOCK"]
                + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="{workday_base_url}/timeTracking/v5/workers/{ID}/workerTimeBlock".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL"),
            ID=workday_resource_id,
        ),
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["CREATEWORKERTIMEBLOCK"],
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Content-Type": "application/json",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }
        ),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def delete_worker_time_block(
    context: ToolContext,
    subresource_id: Annotated[
        str,
        "The Workday ID of the subresource to be deleted. This is specific to the time block associated with the worker.",  # noqa: E501
    ],
    worker_id: Annotated[
        str, "The Workday ID of the worker whose time block you want to delete."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Delete a worker's specific time block by ID.

    This tool deletes a worker time block using the specified IDs for both the worker and the time block. It should be used when needing to remove a specific time entry for a worker."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/timeTracking/v5/workers/{ID}/workerTimeBlock/{subresourceID}".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL"),
            ID=worker_id,
            subresourceID=subresource_id,
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def update_worker_time_block(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    worker_id: Annotated[
        str | None,
        "The unique Workday ID of the worker to update the time block for.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    workday_subresource_id: Annotated[
        str | None,
        "The unique Workday ID of the subresource being updated for the worker's time block.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Update a worker's time block with specified data.

    This tool updates the time block for a specified worker using the provided data. It can set either the timeEntryCode, project, or projectPlanTask, but only one of these fields can be specified at a time. Useful for modifying work hours or project allocations for employees.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["UPDATEWORKERTIMEBLOCK"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not worker_id:
        missing_params.append(("worker_id", "path"))
    if not workday_subresource_id:
        missing_params.append(("workday_subresource_id", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(
                f"Required parameters validation failed: {param_details}"
            ),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["UPDATEWORKERTIMEBLOCK"]
                + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["UPDATEWORKERTIMEBLOCK"]
                + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="{workday_base_url}/timeTracking/v5/workers/{ID}/workerTimeBlock/{subresourceID}".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL"),
            ID=worker_id,
            subresourceID=workday_subresource_id,
        ),
        method="PATCH",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["UPDATEWORKERTIMEBLOCK"],
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Content-Type": "application/json",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }
        ),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def get_worker_time_summary(
    context: ToolContext,
    worker_id: Annotated[
        str, "The unique Workday ID of the worker to retrieve the time summary for."
    ],
    maximum_response_objects: Annotated[
        int | None,
        "Specifies the maximum number of objects in a single response. Acceptable values range from 1 to 100, with a default of 20.",  # noqa: E501
    ] = None,
    period_date: Annotated[
        str | None,
        "Contains the specified date to match a period. Defaults to today's date if not provided.",  # noqa: E501
    ] = None,
    response_start_index: Annotated[
        int | None,
        "The zero-based index of the first object in a response collection. Default is 0. Use with limit for paging.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve a worker's time summary for a specified period.

    Fetches a summary of hours reported by a worker over a time period, based on a specified date or using today's date if none is given. Useful for tracking time and attendance."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/timeTracking/v5/workers/{ID}/timeTotals".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL"), ID=worker_id
        ),
        method="GET",
        params=remove_none_values(
            {
                "limit": maximum_response_objects,
                "offset": response_start_index,
                "periodDate": period_date,
            }
        ),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def retrieve_worker_time_block(
    context: ToolContext,
    worker_time_block_id: Annotated[
        str, "The unique Workday ID of the worker time block to be retrieved."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve details of a worker time block by ID.

    Use this tool to obtain information about a specific worker's time block using the time block's ID. It is secured by Time Block REST APIs and is within the Time Tracking scope."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/timeTracking/v5/workerTimeBlocks/{ID}".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL"),
            ID=worker_time_block_id,
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def submit_time_review_event(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    workday_worker_id: Annotated[
        str | None,
        "The Workday ID of the worker for whom the time review event is being created.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Submit a time review event for a worker.

    Use this tool to create a time review event for a specific worker. Ideal for managers or administrators to submit time on behalf of employees, or for employees to submit their own time for approval. Ensure to specify the date for the time review period. Optionally, include a comment if it's allowed by the business process.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["SUBMITTIMEREVIEWEVENT"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not workday_worker_id:
        missing_params.append(("workday_worker_id", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(
                f"Required parameters validation failed: {param_details}"
            ),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["SUBMITTIMEREVIEWEVENT"]
                + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["SUBMITTIMEREVIEWEVENT"]
                + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="{workday_base_url}/timeTracking/v5/workers/{ID}/timeReviewEvents".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL"),
            ID=workday_worker_id,
        ),
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["SUBMITTIMEREVIEWEVENT"],
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Content-Type": "application/json",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }
        ),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def retrieve_time_clock_events(
    context: ToolContext,
    collection_start_index: Annotated[
        int | None,
        "The zero-based index of the first object in a response. Default is 0. Use with limit to manage pagination.",  # noqa: E501
    ] = None,
    end_date: Annotated[
        str | None, "The end date of the time event in yyyy-mm-dd format."
    ] = None,
    maximum_objects_per_response: Annotated[
        int | None,
        "Specify the maximum number of time clock event records to return in a single response. Accepts an integer between 1 and 100, with a default of 20.",  # noqa: E501
    ] = None,
    start_date: Annotated[
        str | None, "The start date for the time event in yyyy-mm-dd format."
    ] = None,
    worker_ids: Annotated[
        list[str] | None,
        "An array of Workday IDs for workers related to the time block or clock event. Allows multiple IDs for querying multiple workers.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve time clock events based on worker and date range.

    This tool retrieves a collection of time clock events from Workday. It allows filtering by worker and a specific date range to provide the relevant time tracking data."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/timeTracking/v5/timeClockEvents".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL")
        ),
        method="GET",
        params=remove_none_values(
            {
                "fromDate": start_date,
                "limit": maximum_objects_per_response,
                "offset": collection_start_index,
                "toDate": end_date,
                "worker": worker_ids,
            }
        ),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def create_time_clock_event(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Log a time clock event for a specified worker in Workday.

    Use this tool to create time clock event instances for specified workers in Workday. This should be called when you need to log or update a worker's time event, including event type, date, time, and time zone. Ensure no more than one of timeEntryCode, project, or projectPlanTask is included in the request.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["CREATETIMECLOCKEVENT"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["CREATETIMECLOCKEVENT"]
                + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["CREATETIMECLOCKEVENT"]
                + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="{workday_base_url}/timeTracking/v5/timeClockEvents".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL")
        ),
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["CREATETIMECLOCKEVENT"],
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Content-Type": "application/json",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }
        ),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def get_worker_time_attestation(
    context: ToolContext,
    worker_id: Annotated[str, "The ID of the worker's time attestation to retrieve."],
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve worker time attestation by ID.

    This tool retrieves detailed information about a worker's time attestation using the specified ID. It's secured by the Time Clock Event REST API and is used for time tracking purposes."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/timeTracking/v5/workerTimeAttestation/{ID}".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL"), ID=worker_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def get_worker_timezones(
    context: ToolContext,
    effective_date: Annotated[
        str | None,
        "The effective date to look up time values for a given worker. Format: YYYY-MM-DD.",  # noqa: E501
    ] = None,
    response_object_limit: Annotated[
        int | None,
        "Sets the maximum number of objects in a response. Default and max is 1000.",
    ] = None,
    response_offset: Annotated[
        int | None,
        "The starting index for the response collection. Use with 'limit' to manage pagination. Default is 0.",  # noqa: E501
    ] = None,
    worker_id: Annotated[
        str | None, "The Workday ID of the worker to look up time values for."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve available worker time zone instances.

    This tool fetches instances of time zones for workers, which can be used as values for other endpoint parameters in the Workday service. Call this tool to obtain a list of worker time zones."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/timeTracking/v5/values/timeValues/workerTimeZone/".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL")
        ),
        method="GET",
        params=remove_none_values(
            {
                "date": effective_date,
                "limit": response_object_limit,
                "offset": response_offset,
                "worker": worker_id,
            }
        ),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def retrieve_reported_hours(
    context: ToolContext,
    workday_subresource_id: Annotated[
        str,
        "The Workday ID of the subresource to retrieve specific time tracking data.",
    ],
    worker_resource_id: Annotated[
        str, "The Workday ID of the worker whose hours are being retrieved."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve a worker's time summary for a specific period.

    This tool retrieves a summary of reported hours for a worker over a specified period. If no date is specified, it defaults to today's date. Useful for tracking work hours and managing time effectively."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/timeTracking/v5/workers/{ID}/timeTotals/{subresourceID}".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL"),
            ID=worker_resource_id,
            subresourceID=workday_subresource_id,
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def retrieve_time_clock_event(
    context: ToolContext,
    workday_id: Annotated[
        str, "The unique Workday ID of the time clock event to retrieve."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve a specific time clock event by ID.

    Use this tool to obtain information about a time clock event specified by its ID. It is secured by Time Clock Event REST API's and related to time tracking."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/timeTracking/v5/timeClockEvents/{ID}".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL"), ID=workday_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def update_time_clock_event(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    workday_resource_id: Annotated[
        str | None,
        "The unique Workday ID for updating the time clock event.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Update the time clock event for a specified ID.

    Use this tool to replace an existing time clock event with new data for a specified ID. Ensure to specify only one of the fields: timeEntryCode, project, or projectPlanTask. This tool is secured by Time Clock Event REST API's and is under the Time Tracking scope.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["UPDATETIMECLOCKEVENT"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not workday_resource_id:
        missing_params.append(("workday_resource_id", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(
                f"Required parameters validation failed: {param_details}"
            ),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["UPDATETIMECLOCKEVENT"]
                + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["UPDATETIMECLOCKEVENT"]
                + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="{workday_base_url}/timeTracking/v5/timeClockEvents/{ID}".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL"),
            ID=workday_resource_id,
        ),
        method="PUT",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["UPDATETIMECLOCKEVENT"],
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Content-Type": "application/json",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }
        ),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def delete_time_clock_event(
    context: ToolContext,
    workday_resource_id: Annotated[
        str, "The unique Workday ID of the time clock event to be deleted."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Deletes a specific time clock event by ID.

    Use this tool to delete a time clock event using its unique ID. This is secured by the \"Delete Time Clock Event REST API's\" process and is scoped for Time Tracking."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/timeTracking/v5/timeClockEvents/{ID}".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL"),
            ID=workday_resource_id,
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def retrieve_project_plan_task_values(
    context: ToolContext,
    lookup_effective_date: Annotated[
        str | None,
        "The effective date to look up time types for a specific worker. Format: YYYY-MM-DD.",  # noqa: E501
    ] = None,
    maximum_response_objects: Annotated[
        int | None,
        "Set the maximum number of project plan task instances returned in a response. Defaults to 1000.",  # noqa: E501
    ] = None,
    project_id: Annotated[
        str | None, "The Workday ID of a project to filter project plan tasks."
    ] = None,
    response_start_index: Annotated[
        int | None,
        "The zero-based index of the first object in the response. Use with 'limit' for pagination.",  # noqa: E501
    ] = None,
    return_in_out_time_entry_codes_only: Annotated[
        bool | None,
        "Set to true to return only Time Entry Codes of the type In/Out. Use these with POST Time Clock Event.",  # noqa: E501
    ] = None,
    worker_id: Annotated[
        str | None, "The Workday ID of the worker to look up time types for."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve values for project plan tasks in Workday.

    Use this tool to get instances that serve as parameter values for project plan tasks in the Workday service."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/timeTracking/v5/values/timeTypes/projectPlanTasks/".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL")
        ),
        method="GET",
        params=remove_none_values(
            {
                "date": lookup_effective_date,
                "inOutCodeOnly": return_in_out_time_entry_codes_only,
                "limit": maximum_response_objects,
                "offset": response_start_index,
                "project": project_id,
                "worker": worker_id,
            }
        ),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def get_worker_period(
    context: ToolContext,
    worker_id: Annotated[
        str,
        "The unique Workday ID identifying the resource. Provide this ID to specify the worker whose period eligibility is being queried.",  # noqa: E501
    ],
    max_response_objects: Annotated[
        int | None,
        "The maximum number of objects to return in a single response. Default is 20; maximum is 100.",  # noqa: E501
    ] = None,
    response_offset_index: Annotated[
        int | None,
        "The zero-based index of the first object to return in the collection. Defaults to 0. Used with 'limit' for paging.",  # noqa: E501
    ] = None,
    worker_eligibility_date: Annotated[
        str | None,
        "The date to check worker eligibility, using the yyyy-mm-dd format. Defaults to today if not provided.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Get the eligible period for a worker on a specific date.

    Fetches the work period from the period schedule for a specified worker on a given date or defaults to today's date if none is provided. Useful for checking a worker's eligibility in a period schedule."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/timeTracking/v5/workers/{ID}/period".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL"), ID=worker_id
        ),
        method="GET",
        params=remove_none_values(
            {
                "date": worker_eligibility_date,
                "limit": max_response_objects,
                "offset": response_offset_index,
            }
        ),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def retrieve_time_type_projects(
    context: ToolContext,
    effective_date_for_worker: Annotated[
        str | None,
        "The effective date to look up time types for a given worker. Format as YYYY-MM-DD.",  # noqa: E501
    ] = None,
    maximum_response_objects: Annotated[
        int | None,
        "Specifies the maximum number of objects to return in the response. The default and maximum value is 1000.",  # noqa: E501
    ] = None,
    project_id: Annotated[
        str | None,
        "The Workday ID of a project to filter project plan tasks for specific time types.",  # noqa: E501
    ] = None,
    response_start_index: Annotated[
        int | None,
        "The zero-based index of the first object in a response collection. Default is 0. Use this to control paging.",  # noqa: E501
    ] = None,
    return_in_out_codes_only: Annotated[
        bool | None,
        "Set to true to retrieve only Time Entry Codes of type In/Out. Use these with POST Time Clock Event.",  # noqa: E501
    ] = None,
    worker_id: Annotated[
        str | None,
        "The Workday ID of the worker to look up time types for. This is required to filter the results by worker.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieves time type projects for parameter values.

    Use this tool to get instances of time types related to projects, which can be used as parameter values for other endpoints in the Workday service."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/timeTracking/v5/values/timeTypes/projects/".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL")
        ),
        method="GET",
        params=remove_none_values(
            {
                "date": effective_date_for_worker,
                "inOutCodeOnly": return_in_out_codes_only,
                "limit": maximum_response_objects,
                "offset": response_start_index,
                "project": project_id,
                "worker": worker_id,
            }
        ),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def get_worker_time_attestation_prompt(
    context: ToolContext,
    workday_id: Annotated[
        str,
        "The unique Workday ID of the resource to retrieve the follow-up time attestation prompt for a worker.",  # noqa: E501
    ],
    maximum_objects_per_response: Annotated[
        int | None,
        "The maximum number of objects in a single response, with a default of 20 and a maximum of 100.",  # noqa: E501
    ] = None,
    response_offset: Annotated[
        int | None,
        "The zero-based index of the first object to return. Default is 0. Use with limit for pagination.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve follow-up time attestation prompt for a worker.

    This tool is used to get the follow-up time attestation prompt for a specified worker, which is part of the time tracking process."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/timeTracking/v5/workerTimeAttestation/{ID}/followupTimeAttestationPrompt".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL"), ID=workday_id
        ),
        method="GET",
        params=remove_none_values(
            {"limit": maximum_objects_per_response, "offset": response_offset}
        ),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def get_time_values_out_reason(
    context: ToolContext,
    effective_date_for_worker_time_values: Annotated[
        str | None,
        "The effective date to retrieve time values for a specific worker. Format: YYYY-MM-DD.",  # noqa: E501
    ] = None,
    max_objects_per_response: Annotated[
        int | None,
        "Sets the maximum number of objects returned in a single response. Default and max is 1000.",  # noqa: E501
    ] = None,
    response_offset_index: Annotated[
        int | None,
        "The zero-based index for the starting object in the response. Defaults to 0. Used with 'limit' to paginate results.",  # noqa: E501
    ] = None,
    worker_id: Annotated[
        str | None,
        "The identifier for a worker in Workday used to find their time values.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve time values for out reasons in Workday.

    Use this tool to obtain instances of time values specifically for out reasons. This can be used to assist in parameter selection for other Workday API calls."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/timeTracking/v5/values/timeValues/outReason/".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL")
        ),
        method="GET",
        params=remove_none_values(
            {
                "date": effective_date_for_worker_time_values,
                "limit": max_objects_per_response,
                "offset": response_offset_index,
                "worker": worker_id,
            }
        ),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def retrieve_worker_time_blocks(
    context: ToolContext,
    approval_status_ids: Annotated[
        list[str] | None,
        "Array of Workday IDs representing the approval status of the worker time block. Valid IDs include Submitted, Unsubmitted, Approved, Denied, and Sent Back.",  # noqa: E501
    ] = None,
    end_date: Annotated[
        str | None, "The end date of the time block date range in yyyy-mm-dd format."
    ] = None,
    max_response_objects: Annotated[
        int | None,
        "Maximum number of objects in a response. Defaults to 20; up to 100 allowed.",
    ] = None,
    project_phase_ids: Annotated[
        list[str] | None,
        "An array of Workday IDs for the project plan phases to retrieve time blocks. Specify one or more phase IDs using the IDs returned from the GET /planPhases endpoint.",  # noqa: E501
    ] = None,
    project_plan_task_ids: Annotated[
        list[str] | None,
        "A list of Workday IDs for project plan tasks. Specify one or more IDs using results from the GET /planTasks endpoint.",  # noqa: E501
    ] = None,
    project_workday_ids: Annotated[
        list[str] | None,
        "An array of Workday IDs for the project's time blocks. You can specify one or more project IDs, using those returned by the GET /projects endpoint.",  # noqa: E501
    ] = None,
    start_date_of_time_block_range: Annotated[
        str | None, "The start date of the time block date range in yyyy-mm-dd format."
    ] = None,
    start_index_for_pagination: Annotated[
        int | None,
        "The zero-based index of the first object in the response collection for pagination. Default is 0.",  # noqa: E501
    ] = None,
    worker_ids: Annotated[
        list[str] | None,
        "Array of Workday IDs for the workers' time blocks to retrieve. Specify one or more IDs. Use only IDs accessible to the user.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve complete time blocks for specified workers.

    This tool retrieves complete time blocks for specified workers over a given date range. It excludes incomplete time blocks, time offs, and overtime request blocks. Useful for accessing detailed time tracking information."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/timeTracking/v5/workerTimeBlocks".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL")
        ),
        method="GET",
        params=remove_none_values(
            {
                "fromDate": start_date_of_time_block_range,
                "limit": max_response_objects,
                "offset": start_index_for_pagination,
                "phase": project_phase_ids,
                "project": project_workday_ids,
                "projectPlanTask": project_plan_task_ids,
                "status": approval_status_ids,
                "toDate": end_date,
                "worker": worker_ids,
            }
        ),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def get_time_attestation_prompts(
    context: ToolContext,
    event_date_time: Annotated[
        str | None,
        "The date and time of the simulated time clock event in yyyy-mm-ddThh:mm:ss.sss format.",  # noqa: E501
    ] = None,
    event_type_id: Annotated[
        str | None,
        "The Workday ID representing the event type for the simulated time clock event.",  # noqa: E501
    ] = None,
    max_objects_per_response: Annotated[
        int | None,
        "Sets the maximum number of objects to be returned in a single response. Default is 20; maximum is 100.",  # noqa: E501
    ] = None,
    response_offset_index: Annotated[
        int | None,
        "The zero-based index of the first object in a response collection for pagination. Default is 0.",  # noqa: E501
    ] = None,
    time_zone_id: Annotated[
        str | None,
        "The Workday ID representing the time zone for the simulated time clock event.",
    ] = None,
    worker_id: Annotated[
        str | None,
        "The Workday ID representing the worker for the simulated time clock event.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve collection of worker time attestation prompts.

    This tool retrieves prompts that workers need to answer for a time clock event, related to Time Tracking."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/timeTracking/v5/timeAttestationPrompts".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL")
        ),
        method="GET",
        params=remove_none_values(
            {
                "dateTime": event_date_time,
                "eventType": event_type_id,
                "limit": max_objects_per_response,
                "offset": response_offset_index,
                "timeZone": time_zone_id,
                "worker": worker_id,
            }
        ),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def get_job_posting_questionnaires(
    context: ToolContext,
    job_posting_id: Annotated[
        str,
        "The unique Workday ID for the job posting resource to fetch questionnaires for.",  # noqa: E501
    ],
    subresource_id: Annotated[
        str, "The Workday ID of the subresource associated with the job posting."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve questionnaires for a specific job posting.

    Fetches all questionnaires related to a particular job posting ID within the recruiting scope."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/recruiting/v4/jobPostings/{ID}/questionnaire/{subresourceID}".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL"),
            ID=job_posting_id,
            subresourceID=subresource_id,
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def get_interview_details(
    context: ToolContext,
    workday_id: Annotated[
        str, "The unique Workday ID of the interview to retrieve details for."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve details of a specific interview using its ID.

    This tool is used to get information about a particular interview using the interview's unique ID."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/recruiting/v4/interviews/{ID}".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL"), ID=workday_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def get_available_country_values(
    context: ToolContext,
    max_response_objects: Annotated[
        int | None,
        "The maximum number of country instances returned in a response. Defaults to 1000.",  # noqa: E501
    ] = None,
    response_start_index: Annotated[
        int | None,
        "The zero-based index of the first object in the response collection. Default is 0. Use with 'max_results' for paging.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve country instances for endpoint parameter usage.

    This tool retrieves a list of countries that can be used as values for specifying parameters in other Workday service endpoints."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/recruiting/v4/values/common/countries/".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL")
        ),
        method="GET",
        params=remove_none_values(
            {"limit": max_response_objects, "offset": response_start_index}
        ),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def create_prospect_profile(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Create a new prospect instance with specified data.

    This tool creates a prospect profile using the given candidate data. Required fields include candidate.name.country.id, and additional fields may be necessary based on the Recruiting Name Components configuration. Ensure all necessary data is provided to successfully create a prospect.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["CREATEPROSPECTPROFILE"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["CREATEPROSPECTPROFILE"]
                + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["CREATEPROSPECTPROFILE"]
                + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="{workday_base_url}/recruiting/v4/prospects".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL")
        ),
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["CREATEPROSPECTPROFILE"],
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Content-Type": "application/json",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }
        ),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def get_prospect_languages(
    context: ToolContext,
    prospect_id: Annotated[
        str, "The Workday ID of the prospect whose languages are to be retrieved."
    ],
    max_items_per_response: Annotated[
        int | None,
        "Specify the maximum number of language entries to return. Default is 20, maximum is 100.",  # noqa: E501
    ] = None,
    start_index_for_paging: Annotated[
        int | None,
        "The zero-based index of the first object in the response collection. Default is 0. Use with limit for paging.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve languages of a prospect by their ID.

    Obtains the list of languages associated with a specific prospect using their ID. Useful for checking linguistic skills within recruiting and talent pipeline scopes."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/recruiting/v4/prospects/{ID}/languages".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL"), ID=prospect_id
        ),
        method="GET",
        params=remove_none_values(
            {"limit": max_items_per_response, "offset": start_index_for_paging}
        ),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def add_prospect_language_ability(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    prospect_workday_id: Annotated[
        str | None,
        "The unique Workday ID of the prospect for whom the language ability is being added.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Add language abilities for a prospect in Workday.

    Use this tool to add language abilities for a specific prospect in Workday by specifying their language ID, abilities, and ability type. Suitable for both single and bulk additions, supporting up to 100 instances in one request.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["ADDPROSPECTLANGUAGEABILITY"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not prospect_workday_id:
        missing_params.append(("prospect_workday_id", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(
                f"Required parameters validation failed: {param_details}"
            ),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["ADDPROSPECTLANGUAGEABILITY"]
                + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["ADDPROSPECTLANGUAGEABILITY"]
                + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="{workday_base_url}/recruiting/v4/prospects/{ID}/languages".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL"),
            ID=prospect_workday_id,
        ),
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["ADDPROSPECTLANGUAGEABILITY"],
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Content-Type": "application/json",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }
        ),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def get_upcoming_interviews(
    context: ToolContext,
    interview_statuses: Annotated[
        list[str] | None,
        "A list of interview statuses to filter the interview collection. Valid statuses include: AWAITING_ME, COMPLETED, FEEDBACK_COMPLETE, NOT_SCHEDULED, PENDING_FEEDBACK, SCHEDULED, SUBMITTED_FEEDBACK, MAKE_INTERVIEW_DECISION.",  # noqa: E501
    ] = None,
    maximum_objects_per_response: Annotated[
        int | None,
        "The maximum number of interview objects returned in a single response. Defaults to 20, maximum is 100.",  # noqa: E501
    ] = None,
    response_starting_index: Annotated[
        int | None,
        "The zero-based index of the first interview in the response. Default is 0. Use with limit to control response paging.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve a collection of scheduled interviews.

    This tool retrieves scheduled interview details, useful in recruiting contexts. It should be called to get information about upcoming interviews."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/recruiting/v4/interviews".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL")
        ),
        method="GET",
        params=remove_none_values(
            {
                "interviewStatus": interview_statuses,
                "limit": maximum_objects_per_response,
                "offset": response_starting_index,
            }
        ),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def get_prospect_skills(
    context: ToolContext,
    prospect_id: Annotated[
        str, "The unique Workday ID of the prospect whose skills are being retrieved."
    ],
    max_response_objects: Annotated[
        int | None,
        "Specifies the maximum number of skills to return in a single response. Default is 20, with a maximum of 100.",  # noqa: E501
    ] = None,
    response_start_index: Annotated[
        int | None,
        "The zero-based index of the first object in the response collection. Default is 0. Use with 'entry_limit' for paging.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve skills of a prospect using their ID.

    Call this tool to obtain a list of skills associated with a specific prospect by providing their ID. This is useful within the context of recruiting and talent pipeline management."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/recruiting/v4/prospects/{ID}/skills".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL"), ID=prospect_id
        ),
        method="GET",
        params=remove_none_values(
            {"limit": max_response_objects, "offset": response_start_index}
        ),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def add_skills_to_prospect(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    prospect_workday_id: Annotated[
        str | None,
        "The unique Workday ID for the prospect to whom skills will be added.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Add skills to a specific prospect in the recruiting system.

    This tool adds one or multiple skills to a prospect's profile in Workday's recruiting system. Specify the prospect ID and provide the skills as JSON objects in the request body. Use this when you need to update a candidate's skill set.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["ADDSKILLSTOPROSPECT"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not prospect_workday_id:
        missing_params.append(("prospect_workday_id", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(
                f"Required parameters validation failed: {param_details}"
            ),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["ADDSKILLSTOPROSPECT"]
                + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["ADDSKILLSTOPROSPECT"]
                + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="{workday_base_url}/recruiting/v4/prospects/{ID}/skills".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL"),
            ID=prospect_workday_id,
        ),
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["ADDSKILLSTOPROSPECT"],
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Content-Type": "application/json",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }
        ),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def get_work_experience(
    context: ToolContext,
    prospect_id: Annotated[
        str, "The Workday ID of the prospect to retrieve their work experience."
    ],
    subresource_id: Annotated[
        str, "The unique ID of the work experience subresource in Workday."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve work experience details for a specific prospect ID.

    Use this tool to get detailed work experience of a prospect by specifying their ID and the experience subresource ID. This is suitable for tasks related to recruitment and managing talent pipelines."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/recruiting/v4/prospects/{ID}/experiences/{subresourceID}".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL"),
            ID=prospect_id,
            subresourceID=subresource_id,
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def get_candidate_availability_template(
    context: ToolContext,
    workday_resource_id: Annotated[
        str,
        "The Workday ID of the job posting to retrieve the candidate availability template for.",  # noqa: E501
    ],
    response_limit: Annotated[
        int | None,
        "The maximum number of objects in a response. Default is 20; maximum is 100.",
    ] = None,
    starting_index: Annotated[
        int | None,
        "The zero-based index of the first object in the response collection. Default is 0.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve the candidate availability template for a job posting.

    This tool returns the candidate availability template version for the specified job posting ID. It is secured by external job postings and relevant in the recruiting scope."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/recruiting/v4/jobPostings/{ID}/candidateAvailabilityTemplate".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL"),
            ID=workday_resource_id,
        ),
        method="GET",
        params=remove_none_values({"limit": response_limit, "offset": starting_index}),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def get_job_postings(
    context: ToolContext,
    job_category_filters: Annotated[
        list[str] | None,
        "A list of job categories to filter the job postings by. This should be an array of strings, each representing a specific job category.",  # noqa: E501
    ] = None,
    job_posting_identifiers: Annotated[
        list[str] | None,
        "List of job posting identifiers for specific job posting anchors.",
    ] = None,
    job_requisition_list: Annotated[
        list[str] | None,
        "A list of job requisition IDs to filter specific job postings. Each ID is a string.",  # noqa: E501
    ] = None,
    job_site_filters: Annotated[
        list[str] | None,
        "A list of job site identifiers to filter job postings. Provide job site IDs as an array of strings to narrow down results.",  # noqa: E501
    ] = None,
    max_job_postings: Annotated[
        int | None,
        "Specifies the maximum number of job postings to retrieve in one response. Defaults to 20, max is 100.",  # noqa: E501
    ] = None,
    response_offset_index: Annotated[
        int | None,
        "Zero-based index of the first object in a response collection, used with limit to control pagination.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve all job postings with category and site filters.

    This tool fetches all current job postings from the Workday API. It can filter results based on specific job categories and job sites. Ideal for when you need detailed job listings or want to refine your job search by specific parameters."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/recruiting/v4/jobPostings".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL")
        ),
        method="GET",
        params=remove_none_values(
            {
                "category": job_category_filters,
                "jobPosting": job_posting_identifiers,
                "jobRequisition": job_requisition_list,
                "jobSite": job_site_filters,
                "limit": max_job_postings,
                "offset": response_offset_index,
            }
        ),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def get_prospect_language(
    context: ToolContext,
    resource_workday_id: Annotated[
        str,
        "The Workday ID of the resource (prospect) to retrieve language information for.",  # noqa: E501
    ],
    subresource_id: Annotated[
        str, "The Workday ID of the subresource related to the prospect's language."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve language information for a specific prospect.

    Use this tool to get details about a language associated with a specific prospect by their ID. It is secured by Prospects and requires scope for Recruiting or Talent Pipeline."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/recruiting/v4/prospects/{ID}/languages/{subresourceID}".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL"),
            ID=resource_workday_id,
            subresourceID=subresource_id,
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def get_prospect_education(
    context: ToolContext,
    prospect_id: Annotated[
        str, "The unique Workday ID of the prospect to retrieve education details for."
    ],
    maximum_objects_per_response: Annotated[
        int | None,
        "The maximum number of objects to include in a single response. Defaults to 20, with a maximum of 100.",  # noqa: E501
    ] = None,
    response_offset: Annotated[
        int | None,
        "Zero-based index to start the response collection from. Use with limit for paging.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve education details for a specific prospect by ID.

    Use this tool to fetch the education information of a prospect by their unique ID. It is useful in contexts involving recruiting and talent pipeline management."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/recruiting/v4/prospects/{ID}/educations".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL"), ID=prospect_id
        ),
        method="GET",
        params=remove_none_values(
            {"limit": maximum_objects_per_response, "offset": response_offset}
        ),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def create_education_instance_for_prospect(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    workday_resource_id: Annotated[
        str | None,
        "The Workday ID of the prospect to associate the education instance with.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Create an education instance for a specified prospect.

    This tool allows for creating a new education record for a prospect in the Workday system. It should be called when you need to add education details to a prospect's profile. Ensure to include required fields such as school name in the JSON object body.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS[
                "CREATEEDUCATIONINSTANCEFORPROSPECT"
            ],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not workday_resource_id:
        missing_params.append(("workday_resource_id", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(
                f"Required parameters validation failed: {param_details}"
            ),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["CREATEEDUCATIONINSTANCEFORPROSPECT"]
                + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["CREATEEDUCATIONINSTANCEFORPROSPECT"]
                + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="{workday_base_url}/recruiting/v4/prospects/{ID}/educations".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL"),
            ID=workday_resource_id,
        ),
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["CREATEEDUCATIONINSTANCEFORPROSPECT"],
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Content-Type": "application/json",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }
        ),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def get_prospect_skill(
    context: ToolContext,
    resource_workday_id: Annotated[
        str, "The Workday ID of the resource for which the skill is being retrieved."
    ],
    subresource_id: Annotated[
        str,
        "The Workday ID of the subresource to retrieve specific skill details for a prospect.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve a specific skill for a given prospect.

    This tool fetches the skill details using the specified ID for a prospect. It is secured by Prospects and applicable in the Recruiting and Talent Pipeline scope."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/recruiting/v4/prospects/{ID}/skills/{subresourceID}".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL"),
            ID=resource_workday_id,
            subresourceID=subresource_id,
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def get_resume_attachment(
    context: ToolContext,
    prospect_subresource_id: Annotated[
        str,
        "The unique Workday ID of the prospect's subresource for retrieving their resume attachment.",  # noqa: E501
    ],
    workday_resource_id: Annotated[
        str,
        "The unique Workday ID of the prospect's resource to retrieve the resume attachment.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve a prospect's resume attachment by ID.

    Use this tool to get the resume attachment of a specified prospect using their unique ID and subresource ID for recruiting purposes."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/recruiting/v4/prospects/{ID}/resumeAttachments/{subresourceID}".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL"),
            ID=workday_resource_id,
            subresourceID=prospect_subresource_id,
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def get_interview_feedback(
    context: ToolContext,
    resource_workday_id: Annotated[
        str,
        "The Workday ID of the resource for which interview feedback is being retrieved.",  # noqa: E501
    ],
    subresource_id: Annotated[
        str, "The Workday ID of the subresource for which to retrieve feedback."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve interview feedback using an ID.

    Fetches interview feedback for a given interview ID. Useful for reviewing feedback collected during the recruitment process."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/recruiting/v4/interviews/{ID}/feedback/{subresourceID}".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL"),
            ID=resource_workday_id,
            subresourceID=subresource_id,
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def get_job_posting_details(
    context: ToolContext,
    job_posting_id: Annotated[
        str, "The unique Workday ID assigned to the specific job posting to retrieve."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve job posting details by ID from Workday.

    Use this tool to retrieve detailed information about a specific job posting using its ID. Suitable for accessing job details in the context of recruiting."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/recruiting/v4/jobPostings/{ID}".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL"), ID=job_posting_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def get_candidate_availability_template_version(
    context: ToolContext,
    job_posting_id: Annotated[
        str,
        "The Workday ID of the job posting to retrieve the candidate availability template version for.",  # noqa: E501
    ],
    subresource_id: Annotated[
        str, "The Workday ID of the subresource for the job posting."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Get candidate availability template version for a job ID.

    Use this tool to obtain the candidate availability template version associated with a specific job posting ID. Ideal for retrieving availability details for active job postings in the recruiting process."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/recruiting/v4/jobPostings/{ID}/candidateAvailabilityTemplate/{subresourceID}".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL"),
            ID=job_posting_id,
            subresourceID=subresource_id,
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def get_prospect_work_experience(
    context: ToolContext,
    prospect_id: Annotated[
        str,
        "The unique Workday ID representing the prospect. Required to retrieve their work experience.",  # noqa: E501
    ],
    max_objects_per_response: Annotated[
        int | None,
        "The maximum number of work experience entries to retrieve. Default is 20, max is 100.",  # noqa: E501
    ] = None,
    response_offset: Annotated[
        int | None,
        "The zero-based index for the first object in the response collection. Default is 0. Use with limit to manage paging.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieves work experience for a specified prospect by ID.

    Use this tool to obtain the work experience information of a specific prospect by providing their ID. Ideal for use cases involving recruiting and talent pipeline management."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/recruiting/v4/prospects/{ID}/experiences".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL"), ID=prospect_id
        ),
        method="GET",
        params=remove_none_values(
            {"limit": max_objects_per_response, "offset": response_offset}
        ),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def add_prospect_experience(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    resource_workday_id: Annotated[
        str | None,
        "The unique Workday ID representing the prospect resource to add the work experience to.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Add a new work experience entry for a prospect.

    This tool is used to add a new work experience to a prospect's record in Workday. It requires specifying essential details like company name, title, and start year. Use this to update candidate profiles with their professional history.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["ADDPROSPECTEXPERIENCE"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not resource_workday_id:
        missing_params.append(("resource_workday_id", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(
                f"Required parameters validation failed: {param_details}"
            ),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["ADDPROSPECTEXPERIENCE"]
                + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["ADDPROSPECTEXPERIENCE"]
                + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="{workday_base_url}/recruiting/v4/prospects/{ID}/experiences".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL"),
            ID=resource_workday_id,
        ),
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["ADDPROSPECTEXPERIENCE"],
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Content-Type": "application/json",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }
        ),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def fetch_resume_attachment(
    context: ToolContext,
    prospect_resource_id: Annotated[
        str,
        "The Workday ID of the resource associated with the prospect whose resume is being retrieved.",  # noqa: E501
    ],
    subresource_id: Annotated[
        str,
        "Specify the unique Workday ID for the subresource to fetch the attachment related to the candidate.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve resume attachments for a specified prospect.

    This tool retrieves resume files attached to a prospect's profile using their unique ID. It should be called when you need to view resume documents for specific candidates in the recruiting process."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/recruiting/v4/prospects/{ID}/resumeAttachments/{subresourceID}?type=viewFile".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL"),
            ID=prospect_resource_id,
            subresourceID=subresource_id,
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def get_candidate_resumes(
    context: ToolContext,
    prospect_id: Annotated[
        str,
        "The unique Workday ID for the prospect whose resumes you want to retrieve.",
    ],
    max_results_per_response: Annotated[
        int | None,
        "Specifies the maximum number of resumes to return in a single response. Defaults to 20, with a maximum of 100.",  # noqa: E501
    ] = None,
    starting_index_for_paging: Annotated[
        int | None,
        "The zero-based index for the first object in a response. Default is 0. Use with limit for paging; e.g., with limit 5, starting_index_for_paging 9 returns objects starting with the 10th.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve resumes attached to a specified prospect ID.

    This tool retrieves resumes attached to a prospect with the specified ID in the Workday system, secured by candidate data permissions within the recruiting scope."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/recruiting/v4/prospects/{ID}/resumeAttachments".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL"), ID=prospect_id
        ),
        method="GET",
        params=remove_none_values(
            {"limit": max_results_per_response, "offset": starting_index_for_paging}
        ),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def create_resume_attachment(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    resource_id: Annotated[
        str | None,
        "The unique Workday ID for the prospect resource to attach the resume.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Create a new resume attachment for a prospect.

    This tool creates a resume attachment for a specified prospect. It should be called when you need to add a resume file to a prospect's profile in the recruiting system. Requires the fileName and attachmentContent fields.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["CREATERESUMEATTACHMENT"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not resource_id:
        missing_params.append(("resource_id", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(
                f"Required parameters validation failed: {param_details}"
            ),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["CREATERESUMEATTACHMENT"]
                + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["CREATERESUMEATTACHMENT"]
                + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="{workday_base_url}/recruiting/v4/prospects/{ID}/resumeAttachments".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL"), ID=resource_id
        ),
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["CREATERESUMEATTACHMENT"],
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Content-Type": "application/json",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }
        ),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def retrieve_interview_feedback(
    context: ToolContext,
    workday_resource_id: Annotated[
        str, "The unique Workday ID for retrieving the specific interview feedback."
    ],
    response_limit: Annotated[
        int | None,
        "The maximum number of feedback entries to retrieve in a single response. Default is 20; max is 100.",  # noqa: E501
    ] = None,
    starting_index: Annotated[
        int | None,
        "The zero-based index of the first object in the response. Default is 0. Used with limit for paging results.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve interview feedback for a specified ID.

    This tool retrieves feedback from interviews based on a specified interview ID. It should be called when detailed feedback from a particular interview is needed for review or analysis."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/recruiting/v4/interviews/{ID}/feedback".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL"),
            ID=workday_resource_id,
        ),
        method="GET",
        params=remove_none_values({"limit": response_limit, "offset": starting_index}),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def submit_interview_feedback(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    workday_resource_id: Annotated[
        str | None,
        "The unique Workday ID of the interview resource to submit feedback for.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Submit interviewer's rating and comments for an interview.

    This tool is used to submit details about an interview, including the interviewer's rating and comments, for processing in the Workday system. It is secured by the Interview Feedback Public API and operates within the Recruiting scope.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["SUBMITINTERVIEWFEEDBACK"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not workday_resource_id:
        missing_params.append(("workday_resource_id", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(
                f"Required parameters validation failed: {param_details}"
            ),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["SUBMITINTERVIEWFEEDBACK"]
                + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["SUBMITINTERVIEWFEEDBACK"]
                + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="{workday_base_url}/recruiting/v4/interviews/{ID}/feedback".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL"),
            ID=workday_resource_id,
        ),
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["SUBMITINTERVIEWFEEDBACK"],
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Content-Type": "application/json",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }
        ),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def retrieve_job_posting_questionnaires(
    context: ToolContext,
    workday_resource_id: Annotated[
        str,
        "The unique Workday ID of the resource to retrieve questionnaires for. This ID specifies which job posting's questionnaires to access.",  # noqa: E501
    ],
    questionnaire_type_list: Annotated[
        list[str] | None,
        "A list of questionnaire types to filter the collection. Each type should be a string.",  # noqa: E501
    ] = None,
    response_limit: Annotated[
        int | None,
        "Maximum number of questionnaires to retrieve, from 1 to 100. Default is 20.",
    ] = None,
    response_offset: Annotated[
        int | None,
        "Zero-based index of the first object in the response collection. Default is 0. Use with limit for paging.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve recruitment questionnaires for a job posting.

    Use this tool to obtain a collection of questionnaires associated with a specific job posting. It is secured within the scope of job postings for recruiting."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/recruiting/v4/jobPostings/{ID}/questionnaire".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL"),
            ID=workday_resource_id,
        ),
        method="GET",
        params=remove_none_values(
            {
                "limit": response_limit,
                "offset": response_offset,
                "questionnaireType": questionnaire_type_list,
            }
        ),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def get_resume_attachments(
    context: ToolContext,
    workday_resource_id: Annotated[
        str, "The unique Workday ID of the prospect to retrieve resume attachments."
    ],
    maximum_objects_per_response: Annotated[
        int | None,
        "The maximum number of objects to return in a single response. Defaults to 20, maximum is 100.",  # noqa: E501
    ] = None,
    pagination_offset: Annotated[
        int | None,
        "The zero-based index for the start of the response collection. Defaults to 0, used with limit for paging.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve resume attachments for a prospect by ID.

    Use this tool to get resume attachments of a specific prospect from the Workday service, identified by their ID. Suitable for scenarios involving recruitment and candidate data management."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/recruiting/v4/prospects/{ID}/resumeAttachments?type=viewFile".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL"),
            ID=workday_resource_id,
        ),
        method="GET",
        params=remove_none_values(
            {"limit": maximum_objects_per_response, "offset": pagination_offset}
        ),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def retrieve_prospect_education(
    context: ToolContext,
    prospect_id: Annotated[
        str,
        "The Workday ID of the prospect. Used to retrieve specific education details.",
    ],
    subresource_id: Annotated[
        str,
        "The Workday ID of the subresource, used to specify the education record for a prospect.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve education details for a specified prospect.

    Use this tool to get the education details associated with a specific prospect by their ID. Applicable in recruiting and talent pipeline contexts."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/recruiting/v4/prospects/{ID}/educations/{subresourceID}".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL"),
            ID=prospect_id,
            subresourceID=subresource_id,
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def get_prospect_by_id(
    context: ToolContext,
    workday_id: Annotated[
        str, "The Workday ID of the prospect to retrieve details for."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve prospect details using a specific ID.

    Use this tool to get detailed information about a prospect by providing their ID. It is secured by External Career Site Access and is relevant to recruiting and talent pipeline scopes."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/recruiting/v4/prospects/{ID}".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL"), ID=workday_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def get_active_feedback_badges(
    context: ToolContext,
    max_objects_per_response: Annotated[
        int | None,
        "Specifies the maximum number of feedback badges to be returned in a single response. Accepts values from 1 to 100, with a default of 20.",  # noqa: E501
    ] = None,
    results_offset_index: Annotated[
        int | None,
        "The zero-based index of the first object in a response. Defaults to 0. Used with 'results_limit' to control paging.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve all active Feedback Badges.

    This tool retrieves all active feedback badges available in the Workday system. It is secured by the 'Give Feedback' feature and is relevant for Performance Enablement, Worker Profile, and Skills scopes. Use this tool to access current feedback badges."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/performanceManagement/v2/feedbackBadges".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL")
        ),
        method="GET",
        params=remove_none_values(
            {"limit": max_objects_per_response, "offset": results_offset_index}
        ),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def get_feedback_badge(
    context: ToolContext,
    workday_resource_id: Annotated[
        str,
        "The unique Workday ID used to identify the specific feedback badge to retrieve.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve a single feedback badge from Workday.

    Use this tool to get detailed information about a specific feedback badge in Workday. Ideal for accessing performance enablement, worker profile, and skills-related feedback."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/performanceManagement/v2/feedbackBadges/{ID}".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL"),
            ID=workday_resource_id,
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def retrieve_pay_group_by_id(
    context: ToolContext,
    pay_group_id: Annotated[
        str, "The unique Workday ID of the pay group resource to retrieve."
    ],
    subresource_id: Annotated[
        str, "The unique Workday ID of the subresource to retrieve specific details."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve a specific pay group instance by ID.

    Use this tool to obtain details of a pay group instance using its unique ID in the Workday system, secured under 'Set Up: Payroll - Pay Group Specific' and applicable to Core Payroll."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/payroll/v2/jobs/{ID}/payGroup/{subresourceID}".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL"),
            ID=pay_group_id,
            subresourceID=subresource_id,
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def get_pay_group_details(
    context: ToolContext,
    pay_group_id: Annotated[
        str, "The unique Workday ID of the pay group to retrieve details for."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve details of a specific pay group by ID.

    Use this tool to get information about a pay group using its unique ID. Ideal for scenarios involving payroll management and analysis."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/payroll/v2/payGroups/{ID}".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL"), ID=pay_group_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def get_pay_group_for_job(
    context: ToolContext,
    workday_resource_id: Annotated[
        str,
        "The Workday ID associated with the specific job to retrieve its pay group. This is required for identification.",  # noqa: E501
    ],
    effective_date: Annotated[
        str | None, "The effective date of the pay group in yyyy-mm-dd format."
    ] = None,
    max_objects_per_response: Annotated[
        int | None,
        "Specify the maximum number of objects to return in the response. Default is 20; maximum is 100.",  # noqa: E501
    ] = None,
    response_offset: Annotated[
        int | None,
        "The zero-based index of the first object in the response. Default is 0. Use with 'response_limit' for paging.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve the pay group for a given job ID.

    Use this tool to obtain the pay group associated with a specific job ID from the Workday service. This is useful for payroll management and operations."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/payroll/v2/jobs/{ID}/payGroup".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL"),
            ID=workday_resource_id,
        ),
        method="GET",
        params=remove_none_values(
            {
                "effective": effective_date,
                "limit": max_objects_per_response,
                "offset": response_offset,
            }
        ),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def get_company_tax_rate_instances(
    context: ToolContext,
    max_objects_per_response: Annotated[
        int | None,
        "The maximum number of objects to return in a single response, up to 1000.",
    ] = None,
    start_index_of_response_collection: Annotated[
        int | None,
        "Zero-based index for the first object in response. Default is 0. Use with 'max_objects_in_response' for pagination.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve tax rate group instances for companies in Workday.

    Use this tool to get instances that can be used as values for tax rates group parameters in Workday. It helps in fetching specific tax-related company details needed for configuring or querying other endpoints."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/payroll/v2/values/taxRatesGroup/companyInstances/".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL")
        ),
        method="GET",
        params=remove_none_values(
            {
                "limit": max_objects_per_response,
                "offset": start_index_of_response_collection,
            }
        ),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def get_workday_payroll_worktags(
    context: ToolContext,
    end_date_for_positions: Annotated[
        str | None, "The end date for the positions in yyyy-mm-dd format."
    ] = None,
    max_objects_per_response: Annotated[
        int | None,
        "Specify the maximum number of objects to return in a single response. The default and maximum value is 1000.",  # noqa: E501
    ] = None,
    pay_component_id: Annotated[
        str | None,
        "Specify the pay component for the worktags using an ID from GET/values/payrollInputsGroup/payComponents.",  # noqa: E501
    ] = None,
    response_offset_index: Annotated[
        int | None,
        "The zero-based index for the first object in the response to manage paging. Default is 0.",  # noqa: E501
    ] = None,
    start_date_for_positions: Annotated[
        str | None, "The start date for positions, formatted as yyyy-mm-dd."
    ] = None,
    worker_id: Annotated[
        str | None,
        "The Workday ID of the worker, retrievable from the Staffing service's GET /workers endpoint.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve Worktag instances for payroll inputs in Workday.

    Use this tool to get worktags that can be used as values for payroll input parameters in Workday."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/payroll/v2/values/payrollInputsGroup/worktags/".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL")
        ),
        method="GET",
        params=remove_none_values(
            {
                "endDate": end_date_for_positions,
                "limit": max_objects_per_response,
                "offset": response_offset_index,
                "payComponent": pay_component_id,
                "startDate": start_date_for_positions,
                "worker": worker_id,
            }
        ),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def get_pay_group_detail(
    context: ToolContext,
    pay_group_id: Annotated[
        str, "The unique Workday ID to retrieve the pay group details."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve detailed information about a pay group by ID.

    Use this tool to obtain specific pay group details from the Workday system using a unique ID. It is secured and requires the appropriate payroll setup permissions."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/payroll/v2/payGroupDetails/{ID}".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL"), ID=pay_group_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def retrieve_job_collection(
    context: ToolContext,
    maximum_results_per_request: Annotated[
        int | None,
        "Specifies the maximum number of job records to retrieve in one call. Accepts values from 1 to 100, defaulting to 20.",  # noqa: E501
    ] = None,
    starting_index_for_jobs: Annotated[
        int | None,
        "The zero-based index of the first job in the response. Default is 0. Use this with 'max_jobs_to_retrieve' to paginate results.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve a collection of jobs from the Workday system.

    Use this tool to access a collection of job records from the Workday system. It is secured by the Worker Position: View and falls under the Staffing scope."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/payroll/v2/jobs".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL")
        ),
        method="GET",
        params=remove_none_values(
            {"limit": maximum_results_per_request, "offset": starting_index_for_jobs}
        ),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def get_minimum_wage_rates(
    context: ToolContext,
    country_workday_id: Annotated[
        str | None,
        "The Workday ID of the country for minimum wage rates. Specify 1 country ID. Retrieve ID using GET /values/minimumWageRatesGroup/countries.",  # noqa: E501
    ] = None,
    effective_date: Annotated[
        str | None,
        "Specify the date (yyyy-mm-dd) to retrieve minimum wage rates effective on that day.",  # noqa: E501
    ] = None,
    include_local_tax_authorities: Annotated[
        bool | None,
        "Set to true to include local tax authority wage rates along with federal and state rates. Defaults to false.",  # noqa: E501
    ] = None,
    payroll_tax_authorities_ids: Annotated[
        list[str] | None,
        "A list of Workday IDs for payroll tax authorities to retrieve minimum wage rates. Specify one or more IDs.",  # noqa: E501
    ] = None,
    response_limit: Annotated[
        int | None,
        "Specifies the maximum number of minimum wage rates to return in a single response. Defaults to 20, with a maximum of 100.",  # noqa: E501
    ] = None,
    response_offset_index: Annotated[
        int | None,
        "The zero-based index of the first object to return. Use with 'limit' for paging.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve minimum wage rates by country or tax authority.

    This tool retrieves minimum wage rates for specified countries or tax authorities. It should be called when users need detailed information about minimum wage regulations in a specific region."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/payroll/v2/minimumWageRates".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL")
        ),
        method="GET",
        params=remove_none_values(
            {
                "asOfDate": effective_date,
                "country": country_workday_id,
                "includeLocalTaxAuthorities": include_local_tax_authorities,
                "limit": response_limit,
                "offset": response_offset_index,
                "taxAuthority": payroll_tax_authorities_ids,
            }
        ),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def retrieve_workday_run_categories(
    context: ToolContext,
    end_date_for_positions: Annotated[
        str | None, "The end date for the positions in yyyy-mm-dd format."
    ] = None,
    pay_component_id: Annotated[
        str | None,
        "The ID of the pay component for worktags, using the id from GET/values/payrollInputsGroup/payComponents.",  # noqa: E501
    ] = None,
    response_limit: Annotated[
        int | None,
        "Maximum number of objects in a single response, with a default and maximum of 1000.",  # noqa: E501
    ] = None,
    response_offset_index: Annotated[
        int | None,
        "The zero-based index of the first object in the response collection. Default is 0. Use with 'limit' for pagination.",  # noqa: E501
    ] = None,
    start_date_for_positions: Annotated[
        str | None, "The start date for the positions in yyyy-mm-dd format."
    ] = None,
    worker_id: Annotated[
        str | None,
        "The Workday ID of the worker. Retrieved from GET /workers in the Staffing service.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve instances for Workday run categories.

    This tool retrieves instances that serve as possible values for parameters in Workday's payroll inputs, specifically focusing on run categories. Use this tool when you need to obtain available run category instances for subsequent API calls or operations within the Workday service."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/payroll/v2/values/payrollInputsGroup/runCategories/".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL")
        ),
        method="GET",
        params=remove_none_values(
            {
                "endDate": end_date_for_positions,
                "limit": response_limit,
                "offset": response_offset_index,
                "payComponent": pay_component_id,
                "startDate": start_date_for_positions,
                "worker": worker_id,
            }
        ),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def retrieve_job_by_id(
    context: ToolContext,
    job_id: Annotated[str, "The Workday job ID used to retrieve specific job details."],
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve job details using a job ID.

    This tool fetches detailed information about a job by using a specific job ID. It is secured by the 'Worker Position: View' permission and is within the 'Staffing' scope."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/payroll/v2/jobs/{ID}".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL"), ID=job_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def retrieve_pay_group_details(
    context: ToolContext,
    collection_offset_index: Annotated[
        int | None,
        "The zero-based index of the first object in the response. Default is 0. Use with limit to page results. E.g., offset 9 with limit 5 returns objects 10-14.",  # noqa: E501
    ] = None,
    maximum_response_objects: Annotated[
        int | None,
        "Specify the maximum number of objects to return in one response. Defaults to 20, with a maximum of 100.",  # noqa: E501
    ] = None,
    run_category_ids: Annotated[
        list[str] | None,
        "Array of Workday IDs for run categories applicable to the pay group. Specify one or more IDs, e.g., ['category1', 'category2'].",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve active pay group details securely.

    This tool retrieves all active pay group details. It does not include inactive or external pay groups and is secured by specific payroll setup permissions. Use this to access core payroll information."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/payroll/v2/payGroupDetails".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL")
        ),
        method="GET",
        params=remove_none_values(
            {
                "limit": maximum_response_objects,
                "offset": collection_offset_index,
                "runCategories": run_category_ids,
            }
        ),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def retrieve_payroll_positions(
    context: ToolContext,
    end_date_for_positions: Annotated[
        str | None, "The end date for the positions using the format yyyy-mm-dd."
    ] = None,
    max_objects_per_response: Annotated[
        int | None,
        "Specify the maximum number of objects returned in a single response, up to 1000.",  # noqa: E501
    ] = None,
    pay_component_id: Annotated[
        str | None,
        "The ID for the pay component. Use an ID returned from GET/values/payrollInputsGroup/payComponents.",  # noqa: E501
    ] = None,
    response_offset: Annotated[
        int | None,
        "Zero-based start index for response collection; use with 'limit' for paging.",
    ] = None,
    start_date_for_positions: Annotated[
        str | None, "The start date for the positions in yyyy-mm-dd format."
    ] = None,
    worker_id: Annotated[
        str | None,
        "The Workday ID of the worker. Retrieve this ID using GET /workers in the Staffing service.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve payroll input group positions for parameter values.

    This tool retrieves instances of payroll input group positions that can be used as parameter values in other Workday API endpoints. It's useful when you need to specify valid positions for payroll-related operations."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/payroll/v2/values/payrollInputsGroup/positions/".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL")
        ),
        method="GET",
        params=remove_none_values(
            {
                "endDate": end_date_for_positions,
                "limit": max_objects_per_response,
                "offset": response_offset,
                "payComponent": pay_component_id,
                "startDate": start_date_for_positions,
                "worker": worker_id,
            }
        ),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def get_payroll_input_by_id(
    context: ToolContext,
    workday_resource_id: Annotated[
        str, "The unique Workday ID of the payroll input resource."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve payroll input details by ID.

    Fetch details of a payroll input using its unique ID within the Core Payroll scope. Utilize this tool when access to specific payroll input information is needed."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/payroll/v2/payrollInputs/{ID}".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL"),
            ID=workday_resource_id,
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def delete_payroll_input(
    context: ToolContext,
    workday_resource_id: Annotated[
        str, "The Workday ID of the payroll input instance to delete."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Deletes a payroll input instance by ID.

    This tool deletes an existing payroll input instance using the specified ID. It is secured by Self-Service: Payroll Public API and requires Pay Component Segment Security configuration. The tool should be called when you need to remove a payroll input record from the system."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/payroll/v2/payrollInputs/{ID}".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL"),
            ID=workday_resource_id,
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def update_payroll_input(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    workday_resource_id: Annotated[
        str | None,
        "The unique Workday ID of the payroll input resource to be updated.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Partially update payroll input details by ID.

    Use this tool to partially update an existing payroll input instance for a specified ID. Before calling this tool, retrieve current payroll input data using GET /payrollInputs. The 'worker' field cannot be updated. Field editability is determined by specific conditions related to the payroll inputs.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["UPDATEPAYROLLINPUT"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not workday_resource_id:
        missing_params.append(("workday_resource_id", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(
                f"Required parameters validation failed: {param_details}"
            ),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["UPDATEPAYROLLINPUT"]
                + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["UPDATEPAYROLLINPUT"]
                + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="{workday_base_url}/payroll/v2/payrollInputs/{ID}".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL"),
            ID=workday_resource_id,
        ),
        method="PATCH",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["UPDATEPAYROLLINPUT"],
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Content-Type": "application/json",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }
        ),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def retrieve_minimum_wage_rates(
    context: ToolContext,
    workday_resource_id: Annotated[
        str,
        "The unique Workday ID of the resource for retrieving specific minimum wage rates.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Fetches minimum wage rates for a specific region.

    Use this tool to obtain minimum wage rates by specifying a country or a tax authority. It's secured by various payroll and compensation setups in Canada and the USA and supports scopes like CAN Payroll, Core Compensation, and USA Payroll."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/payroll/v2/minimumWageRates/{ID}".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL"),
            ID=workday_resource_id,
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def get_available_tax_authorities(
    context: ToolContext,
    country_id: Annotated[
        str | None,
        "The Workday ID of the country for tax authorities. Use an ID from GET /values/minimumWageRatesGroup/countries.",  # noqa: E501
    ] = None,
    include_local_tax_authorities: Annotated[
        bool | None,
        "Set to true to include local tax authorities (cities and counties) along with federal and state authorities. Default is false.",  # noqa: E501
    ] = None,
    max_results: Annotated[
        int | None,
        "The maximum number of tax authorities to return in the response. Default and maximum is 1000.",  # noqa: E501
    ] = None,
    response_start_index: Annotated[
        int | None,
        "Index of the first object in the response collection, zero-based. Use with 'number_of_objects' for paging.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve available tax authorities for minimum wage queries.

    This tool fetches a list of tax authorities which can be used as query parameters when accessing minimum wage rates data."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/payroll/v2/values/minimumWageRatesGroup/taxAuthorities/".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL")
        ),
        method="GET",
        params=remove_none_values(
            {
                "country": country_id,
                "includeLocalTaxAuthorities": include_local_tax_authorities,
                "limit": max_results,
                "offset": response_start_index,
            }
        ),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def retrieve_payroll_inputs(
    context: ToolContext,
    end_date_filter: Annotated[
        str | None,
        "The end date for filtering payroll inputs, active on or before this date, in yyyy-mm-dd format.",  # noqa: E501
    ] = None,
    max_objects_per_response: Annotated[
        int | None,
        "Sets the maximum number of payroll inputs to return in a single response. Defaults to 20, maximum is 100.",  # noqa: E501
    ] = None,
    pay_component_ids: Annotated[
        list[str] | None,
        "An array of Workday IDs for pay components, used to filter payroll inputs. Retrieve IDs from GET /values/payrollInputsGroup/payComponents.",  # noqa: E501
    ] = None,
    response_offset_index: Annotated[
        int | None,
        "The zero-based index of the first object in the response. Default is 0. Use with 'limit' for paging, e.g., limit=5 and offset=9 returns 5 objects starting at the 10th object.",  # noqa: E501
    ] = None,
    start_date_filter: Annotated[
        str | None,
        "A date in yyyy-mm-dd format to filter payroll inputs active on or after this date.",  # noqa: E501
    ] = None,
    worker_ids: Annotated[
        list[str] | None,
        "List of Workday IDs for workers to filter payroll inputs. Use IDs from GET /workers in the Staffing service.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve all payroll inputs with required query parameters.

    This tool retrieves all payroll inputs using the Workday API. At least one query parameter is required. The tool provides details on payroll inputs and their editability status, allowing users to view their payroll data. Useful for accessing and managing payroll information."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/payroll/v2/payrollInputs".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL")
        ),
        method="GET",
        params=remove_none_values(
            {
                "endDate": end_date_filter,
                "limit": max_objects_per_response,
                "offset": response_offset_index,
                "payComponent": pay_component_ids,
                "startDate": start_date_filter,
                "worker": worker_ids,
            }
        ),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def create_payroll_input(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Creates a payroll input instance with specified data.

    Use this tool to create a payroll input instance by specifying required fields such as worker, pay component, and start date. Additional requirements may include position, worktag, endDate, and type fields based on the input details.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["CREATEPAYROLLINPUT"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["CREATEPAYROLLINPUT"]
                + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["CREATEPAYROLLINPUT"]
                + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="{workday_base_url}/payroll/v2/payrollInputs".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL")
        ),
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["CREATEPAYROLLINPUT"],
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Content-Type": "application/json",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }
        ),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def get_tax_rates_state_instances(
    context: ToolContext,
    maximum_number_of_objects: Annotated[
        int | None,
        "Sets the maximum number of objects to return in a single response, with a default and maximum of 1000.",  # noqa: E501
    ] = None,
    response_offset_index: Annotated[
        int | None,
        "The starting index for returned objects in a response, used to paginate results. Defaults to 0.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve state tax rate instances for parameter values.

    This tool retrieves instances of state tax rates that can be used as parameter values in other API endpoints. It is useful when you need to populate state tax rate values for API integration within the Workday service."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/payroll/v2/values/taxRatesGroup/stateInstances/".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL")
        ),
        method="GET",
        params=remove_none_values(
            {"limit": maximum_number_of_objects, "offset": response_offset_index}
        ),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def get_available_countries_for_minimum_wages(
    context: ToolContext,
    country_workday_id: Annotated[
        str | None,
        "The Workday ID of the country for tax authorities, used in queries for minimum wage rates.",  # noqa: E501
    ] = None,
    include_local_tax_authorities: Annotated[
        bool | None,
        "Set to true to include local tax authorities (cities and counties). Default is false for federal and state only.",  # noqa: E501
    ] = None,
    response_limit: Annotated[
        int | None,
        "Sets the maximum number of countries returned in a single response. Accepts an integer up to 1000.",  # noqa: E501
    ] = None,
    response_offset_index: Annotated[
        int | None,
        "The zero-based index of the first object in a response collection. Default is 0. Use with 'limit' to control paging.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve a list of countries for minimum wage queries.

    This tool retrieves a list of countries that can be used as query parameters in the minimum wage rates endpoint. Use this to determine which countries are available for checking minimum wage rates."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/payroll/v2/values/minimumWageRatesGroup/countries/".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL")
        ),
        method="GET",
        params=remove_none_values(
            {
                "country": country_workday_id,
                "includeLocalTaxAuthorities": include_local_tax_authorities,
                "limit": response_limit,
                "offset": response_offset_index,
            }
        ),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def get_company_sui_rates(
    context: ToolContext,
    company_reference_ids: Annotated[
        str | None,
        "A comma-separated list of company reference IDs or WIDs representing one or more companies.",  # noqa: E501
    ] = None,
    effective_date_for_sui_rate: Annotated[
        str | None, "Date for the SUI rate to be effective, in yyyy-mm-dd format."
    ] = None,
    maximum_number_of_objects: Annotated[
        int | None,
        "Specify the maximum number of objects in the response, between 1 and 100. The default is 20.",  # noqa: E501
    ] = None,
    response_offset_index: Annotated[
        int | None,
        "Specifies the starting point of objects in the response. Default is 0. Used with 'limit' to control paging.",  # noqa: E501
    ] = None,
    state_authority_tax_code: Annotated[
        str | None,
        "The FIPS code or WID for one or more states to filter SUI rates. Separate multiple codes with '&'.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve company SUI rates for specific criteria.

    Use this tool to get all company State Unemployment Insurance (SUI) rates. You can filter the results by company, payroll state authority tax code, or effective date. This is secured by the Tax Filing/W-2s process and is applicable for USA Payroll."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/payroll/v2/taxRates".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL")
        ),
        method="GET",
        params=remove_none_values(
            {
                "company": company_reference_ids,
                "effective": effective_date_for_sui_rate,
                "limit": maximum_number_of_objects,
                "offset": response_offset_index,
                "payrollStateAuthorityTaxCode": state_authority_tax_code,
            }
        ),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def create_company_sui_rates(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Create company State Unemployment Insurance (SUI) rates.

    This tool is used to create one or multiple company SUI rates for USA Payroll. It requires specifying necessary fields like companyInstance, stateInstance, taxCode, and startDate. Use for managing payroll tax filings.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["CREATECOMPANYSUIRATES"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["CREATECOMPANYSUIRATES"]
                + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["CREATECOMPANYSUIRATES"]
                + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="{workday_base_url}/payroll/v2/taxRates".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL")
        ),
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["CREATECOMPANYSUIRATES"],
        params=remove_none_values({}),
        headers=remove_none_values(
            {
                "Content-Type": "application/json",
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                ),
            }
        ),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def get_payroll_input_values(
    context: ToolContext,
    end_date_for_positions: Annotated[
        str | None, "The end date for the positions in yyyy-mm-dd format."
    ] = None,
    pay_component_id: Annotated[
        str | None,
        "The ID of the pay component for the worktags. Obtainable via GET/values/payrollInputsGroup/payComponents.",  # noqa: E501
    ] = None,
    response_limit: Annotated[
        int | None,
        "Maximum number of objects in a single response. Default and maximum is 1000.",
    ] = None,
    response_offset: Annotated[
        int | None,
        "Zero-based index for starting object in response. Used with limit for response paging. Default is 0.",  # noqa: E501
    ] = None,
    start_date: Annotated[
        str | None, "The start date for the positions in yyyy-mm-dd format."
    ] = None,
    worker_id: Annotated[
        str | None,
        "The Workday ID of the worker. This ID can be obtained from the Staffing service using a GET request to /workers.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve payroll input values for Workday API.

    This tool retrieves instances that can be used as values for other endpoint parameters in the Workday service, specifically for payroll input groups and components."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/payroll/v2/values/payrollInputsGroup/payComponents/".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL")
        ),
        method="GET",
        params=remove_none_values(
            {
                "endDate": end_date_for_positions,
                "limit": response_limit,
                "offset": response_offset,
                "payComponent": pay_component_id,
                "startDate": start_date,
                "worker": worker_id,
            }
        ),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="workday"), requires_secrets=["WORKDAY_BASE_URL"])
async def get_active_pay_groups(
    context: ToolContext,
    collection_start_index: Annotated[
        int | None,
        "The zero-based index of the first pay group object to return. Defaults to 0. Used with limit for pagination (e.g., if limit is 5 and offset is 9, returns 5 objects starting from the 10th).",  # noqa: E501
    ] = None,
    country_workday_id: Annotated[
        str | None,
        "The Workday ID for the country or territory of the pay group. Use an ID from any payGroups endpoint in this API.",  # noqa: E501
    ] = None,
    maximum_response_objects: Annotated[
        int | None,
        "The maximum number of pay groups to retrieve in one response. Defaults to 20; maximum is 100.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint ''."]:
    """Retrieve all active pay groups in Workday.

    This tool retrieves all active pay groups from Workday, excluding inactive and external ones, within the scope of Core Payroll."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="{workday_base_url}/payroll/v2/payGroups".format(  # noqa: UP032
            workday_base_url=context.get_secret("WORKDAY_BASE_URL")
        ),
        method="GET",
        params=remove_none_values(
            {
                "country": country_workday_id,
                "limit": maximum_response_objects,
                "offset": collection_start_index,
            }
        ),
        headers=remove_none_values(
            {
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }
        ),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}

